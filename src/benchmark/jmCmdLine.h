/***********************************************************************
  THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
  DEVELOPER: CodePack https://github.com/vczh-libraries/Tools
***********************************************************************/

/***********************************************************************
  jstd\char_traits.h
***********************************************************************/

#ifndef JSTD_CHAR_TRAITS_H
#define JSTD_CHAR_TRAITS_H

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <type_traits>

namespace jstd {

template <typename T>
struct no_signed_char_trait {
    typedef T type;
};

template <>
struct no_signed_char_trait<unsigned char> {
    typedef char type;
};

template <>
struct no_signed_char_trait<signed char> {
    typedef char type;
};

template <>
struct no_signed_char_trait<unsigned short> {
    typedef short type;
};

template <>
struct no_signed_char_trait<signed short> {
    typedef short type;
};

template <>
struct no_signed_char_trait<wchar_t> {
    typedef wchar_t type;
};

template <>
struct no_signed_char_trait<char16_t> {
    typedef char16_t type;
};

template <>
struct no_signed_char_trait<char32_t> {
    typedef char32_t type;
};

template <>
struct no_signed_char_trait<unsigned int> {
    typedef int type;
};

template <>
struct no_signed_char_trait<signed int> {
    typedef int type;
};

template <>
struct no_signed_char_trait<unsigned long> {
    typedef long type;
};

template <>
struct no_signed_char_trait<signed long> {
    typedef long type;
};

template <>
struct no_signed_char_trait<unsigned long long> {
    typedef long long type;
};

template <>
struct no_signed_char_trait<signed long long> {
    typedef long long type;
};

template <typename T>
struct char_traits {
	static_assert(
		((std::is_integral<T>::value || std::is_enum<T>::value) &&
			!std::is_same<T, bool>::value),
        "jstd::char_trait<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

    typedef typename std::remove_reference<
                typename std::remove_pointer<
                    typename std::remove_extent<
                        typename std::remove_cv<T>::type
                    >::type
                >::type
            >::type CharT;

    typedef typename std::make_unsigned<CharT>::type    Unsigned;
    typedef typename std::make_signed<CharT>::type      Signed;
    typedef typename no_signed_char_trait<CharT>::type  NoSigned;
};

} // namespace jstd

#endif // JSTD_CHAR_TRAITS_H

/***********************************************************************
  jstd\apply_visitor.h
***********************************************************************/

#ifndef JSTD_APPLY_VISITOR_H
#define JSTD_APPLY_VISITOR_H

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif


namespace jstd {

///////////////////////////////////////////////////////////////////////////////////////

namespace detail {

struct faked_return_void
{
    faked_return_void() noexcept {
    }

    template <typename T>
    faked_return_void(const T &) noexcept {
    }

    template <typename T>
    faked_return_void(T &&) noexcept {
    }
};

#if (JSTD_IS_CPP_14 == 0)
bool operator == (faked_return_void, faked_return_void) noexcept { return true;  }
bool operator != (faked_return_void, faked_return_void) noexcept { return false; }
bool operator  < (faked_return_void, faked_return_void) noexcept { return false; }
bool operator  > (faked_return_void, faked_return_void) noexcept { return false; }
bool operator <= (faked_return_void, faked_return_void) noexcept { return true;  }
bool operator >= (faked_return_void, faked_return_void) noexcept { return true;  }
#else
constexpr bool operator == (faked_return_void, faked_return_void) noexcept { return true;  }
constexpr bool operator != (faked_return_void, faked_return_void) noexcept { return false; }
constexpr bool operator  < (faked_return_void, faked_return_void) noexcept { return false; }
constexpr bool operator  > (faked_return_void, faked_return_void) noexcept { return false; }
constexpr bool operator <= (faked_return_void, faked_return_void) noexcept { return true;  }
constexpr bool operator >= (faked_return_void, faked_return_void) noexcept { return true;  }
#endif

template <typename T>
struct return_type_wrapper
{
    typedef T type;
};

template <>
struct return_type_wrapper<void>
{
    typedef faked_return_void type;
};

template <typename T>
struct has_result_type
{
private:
    typedef char Yes;
    typedef struct {
        char array[2];
    } No;

    template <typename Class>
    static Yes test(typename std::remove_reference<typename Class::result_type>::type *);

    template <typename Class>
    static No  test(...);

public:
    static constexpr bool value = (sizeof(test<T>(0)) == sizeof(Yes));
};

struct is_static_visitor_tag {
};

template <typename T>
struct is_static_visitor_impl
{
    static constexpr bool value = std::is_base_of<is_static_visitor_tag, T>::value;
};

} // namespace detail

///////////////////////////////////////////////////////////////////////////////////////

template <typename ReturnType = void>
struct static_visitor : public detail::is_static_visitor_tag
{
    typedef ReturnType result_type;

    static_visitor() = default;
    ~static_visitor() = default;
};

template <typename T>
struct is_static_visitor : public std::integral_constant<bool, detail::is_static_visitor_impl<T>::value> {
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename BinaryVisitor, typename Value1, bool IsMoveSemantics>
class apply_visitor_binary_invoke
{
public:
    typedef typename BinaryVisitor::result_type result_type;

private:
    BinaryVisitor & visitor_;
    Value1 &        value1_;

public:
    apply_visitor_binary_invoke(BinaryVisitor & visitor, Value1 & value1) noexcept
        : visitor_(visitor), value1_(value1) {
    }

    apply_visitor_binary_invoke(BinaryVisitor && visitor, Value1 && value1) noexcept
        : visitor_(std::forward<BinaryVisitor>(visitor)), value1_(std::forward<Value1>(value1)) {
    }

    template <typename Value2>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Value2, Value2>::value),
        typename detail::return_type_wrapper<result_type>::type
    >::type
    operator () (Value2 && value2)
    {
        return visitor_(std::move(value1_), std::forward<Value2>(value2));
    }

    template <typename Value2>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Value2, Value2>::value),
        typename detail::return_type_wrapper<result_type>::type
    >::type
    operator () (Value2 && value2)
    {
        return visitor_(value1_, std::forward<Value2>(value2));
    }

private:
    apply_visitor_binary_invoke & operator = (const apply_visitor_binary_invoke &);
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename BinaryVisitor, typename Visitable2, bool IsMoveSemantics>
class apply_visitor_binary_unwrap
{
public:
    typedef typename BinaryVisitor::result_type result_type;

private:
    BinaryVisitor & visitor_;
    Visitable2 &    visitable2_;

public:
    apply_visitor_binary_unwrap(BinaryVisitor & visitor, Visitable2 & visitable2) noexcept
        : visitor_(visitor), visitable2_(visitable2) {
    }

    template <typename Value1>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Value1, Value1>::value),
        typename detail::return_type_wrapper<result_type>::type
    >::type
    operator () (Value1 && value1)
    {
        apply_visitor_binary_invoke<BinaryVisitor, Value1,
            !std::is_lvalue_reference<Value1>::value> invoker(visitor_, value1);
        return apply_visitor(invoker, std::move(visitable2_));
    }

    template <typename Value1>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Value1, Value1>::value),
        typename detail::return_type_wrapper<result_type>::type
    >::type
    operator () (Value1 && value1)
    {
        apply_visitor_binary_invoke<BinaryVisitor, Value1,
            !std::is_lvalue_reference<Value1>::value> invoker(visitor_, value1);
        return apply_visitor(invoker, visitable2_);
    }

private:
    apply_visitor_binary_unwrap & operator = (const apply_visitor_binary_unwrap &);
};

///////////////////////////////////////////////////////////////////////////////////////

//
// non-const visitor version:
//
template <typename BinaryVisitor, typename Visitable1, typename Visitable2>
inline
typename std::enable_if<!std::is_const<BinaryVisitor>::value,
                        typename detail::return_type_wrapper<
                            typename BinaryVisitor::result_type
                          >::type
                       >::type
apply_visitor(BinaryVisitor & visitor, Visitable1 && visitable1, Visitable2 && visitable2)
{
    apply_visitor_binary_unwrap<BinaryVisitor, Visitable2,
        !std::is_lvalue_reference<Visitable2>::value> unwrapper(visitor, visitable2);
    return apply_visitor(unwrapper, std::forward<Visitable1>(visitable1));
}

//
// const visitor version:
//
template <typename BinaryVisitor, typename Visitable1, typename Visitable2>
inline
typename detail::return_type_wrapper<typename BinaryVisitor::result_type>::type
apply_visitor(const BinaryVisitor & visitor, Visitable1 && visitable1, Visitable2 && visitable2)
{
    apply_visitor_binary_unwrap<const BinaryVisitor, Visitable2,
        !std::is_lvalue_reference<Visitable2>::value> unwrapper(visitor, visitable2);
    return apply_visitor(unwrapper, std::forward<Visitable1>(visitable1));
}

///////////////////////////////////////////////////////////////////////////////////////

//
// non-const visitor version:
//
template <typename Visitor, typename Visitable>
inline
typename std::enable_if<!std::is_const<Visitor>::value,
                        typename detail::return_type_wrapper<
                            typename Visitor::result_type
                          >::type
                       >::type
apply_visitor(Visitor & visitor, Visitable && visitable)
{
    return std::forward<Visitable>(visitable).apply_visitor(visitor);
}

//
// const visitor version:
//
template <typename Visitor, typename Visitable>
inline
typename detail::return_type_wrapper<typename Visitor::result_type>::type
apply_visitor(const Visitor & visitor, Visitable && visitable)
{
    return std::forward<Visitable>(visitable).apply_visitor(visitor);
}

///////////////////////////////////////////////////////////////////////////////////////

template <typename Visitor>
class apply_visitor_delayed_t
{
public:
    typedef typename Visitor::result_type result_type;

private:
    Visitor & visitor_;

public:
    explicit apply_visitor_delayed_t(Visitor & visitor) noexcept
      : visitor_(visitor) {
    }

    template <typename... Visitables>
    result_type operator () (Visitables &&... visitables) const
    {
        return apply_visitor(visitor_, std::forward<Visitables>(visitables)...);
    }

private:
    apply_visitor_delayed_t & operator = (const apply_visitor_delayed_t &);
};

///////////////////////////////////////////////////////////////////////////////////////

} // namespace jstd

#endif // JSTD_APPLY_VISITOR_H

/***********************************************************************
  jstd\function_traits.h
***********************************************************************/

#ifndef JSTD_FUNCTION_TRAITS_H
#define JSTD_FUNCTION_TRAITS_H

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <cstdint>
#include <cstddef>
#include <cstdbool>

#include <tuple>
#include <functional>


namespace jstd {

///////////////////////////////////////////////////////////////////////////////////////

struct void_type {
    void_type() noexcept {}

    template <typename T>
    void_type(const T &) noexcept {
    }

    template <typename T>
    void_type(T &&) noexcept {
    }
};

#if (JSTD_IS_CPP_14 == 0)
bool operator == (void_type, void_type) noexcept { return true;  }
bool operator != (void_type, void_type) noexcept { return false; }
bool operator  < (void_type, void_type) noexcept { return false; }
bool operator  > (void_type, void_type) noexcept { return false; }
bool operator <= (void_type, void_type) noexcept { return true;  }
bool operator >= (void_type, void_type) noexcept { return true;  }
#else
constexpr bool operator == (void_type, void_type) noexcept { return true;  }
constexpr bool operator != (void_type, void_type) noexcept { return false; }
constexpr bool operator  < (void_type, void_type) noexcept { return false; }
constexpr bool operator  > (void_type, void_type) noexcept { return false; }
constexpr bool operator <= (void_type, void_type) noexcept { return true;  }
constexpr bool operator >= (void_type, void_type) noexcept { return true;  }
#endif

template <typename T>
struct return_type_wrapper
{
    typedef T type;
};

template <>
struct return_type_wrapper<void>
{
    typedef void_type type;
};

template <typename T>
struct return_type_traits {
    typedef T result_type;
    typedef typename std::remove_cv<
                typename std::remove_reference<result_type
                >::type
            >::type type;
};

///////////////////////////////////////////////////////////////////////////////////////

namespace detail {

template <typename T>
struct remove_cvr {
    typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;
};

} // namespace detail

///////////////////////////////////////////////////////////////////////////////////////

template <typename... Ts>
struct make_void {
    typedef void type;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

///////////////////////////////////////////////////////////////////////////////////////

template <std::size_t I, typename... Args>
struct tuple_element_helper {
    static constexpr std::size_t arity = sizeof...(Args);

    static_assert(((I < arity) || (arity == 0)), "Error: invalid parameter index.");
    using type = typename std::conditional<(arity == 0), void_type,
                 typename std::tuple_element<I + ((arity != 0) ? 1 : 0), std::tuple<void_type, Args...>>::type>::type;
};

///////////////////////////////////////////////////////////////////////////////////////

//
// Specializing a template on a lambda in C++0x
// See: https://stackoverflow.com/questions/2562320/specializing-a-template-on-a-lambda-in-c0x
//
// See: https://www.cnblogs.com/qicosmos/p/4772328.html
//
// See: https://stackoverflow.com/questions/34283919/understanding-how-the-function-traits-template-works-in-particular-what-is-the
//
// C++ 11 Function Traits
// See: https://functionalcpp.wordpress.com/2013/08/05/function-traits/
//

template <typename Functor>
struct function_traits;

///////////////////////////////////////////////////////////////////////////////////////

// Specialize for normal function
template <typename ReturnType, typename... Args>
struct function_traits<ReturnType(Args...)> {
    static constexpr std::size_t arity = sizeof...(Args);

    typedef void_type           functor_type;
    typedef std::tuple<Args...> args_type;

    typedef typename return_type_wrapper<ReturnType>::type result_type;

    typedef ReturnType(*type)(Args...);

    template <std::size_t I>
    struct arguments {
        static_assert((I < arity) || (arity == 0),
                      "Error: function_traits<ReturnType(Args...)>: invalid parameter index.");
        using type = typename tuple_element_helper<I, Args...>::type;
    };

    typedef typename tuple_element_helper<0, Args...>::type arg0;
    typedef std::function<ReturnType(Args...)> func_type;
};

// Specialize for function pointer
template <typename ReturnType, typename... Args>
struct function_traits<ReturnType(*)(Args...)> {
    static constexpr std::size_t arity = sizeof...(Args);

    typedef void_type           functor_type;
    typedef std::tuple<Args...> args_type;

    typedef typename return_type_wrapper<ReturnType>::type result_type;

    typedef ReturnType(*type)(Args...);

    template <std::size_t I>
    struct arguments {
        static_assert((I < arity) || (arity == 0),
                      "Error: function_traits<ReturnType(*)(Args...)>: invalid parameter index.");
        using type = typename tuple_element_helper<I, Args...>::type;
    };

    typedef typename tuple_element_helper<0, Args...>::type arg0;
    typedef std::function<ReturnType(Args...)> func_type;
};

// Specialize for member function pointer
template <typename ReturnType, typename Functor, typename... Args>
struct function_traits<ReturnType(Functor::*)(Args...)>
    /* : public function_traits<ReturnType(T &, Args...)> */ {
    static constexpr std::size_t arity = sizeof...(Args);

    typedef Functor             functor_type;
    typedef std::tuple<Args...> args_type;

    typedef typename return_type_wrapper<ReturnType>::type result_type;

    typedef decltype(&Functor::operator ()) type;

    template <std::size_t I>
    struct arguments {
        static_assert((I < arity), "Error: invalid parameter index.");
        using type = typename tuple_element_helper<I, Args...>::type;
    };

    typedef typename tuple_element_helper<0, Args...>::type arg0;
    typedef std::function<ReturnType(Functor &, Args...)> func_type;
};

// Specialize for const member function pointer
template <typename ReturnType, typename Functor, typename... Args>
struct function_traits<ReturnType(Functor::*)(Args...) const>
    /* : public function_traits<ReturnType(const T &, Args...)> */ {
    static constexpr std::size_t arity = sizeof...(Args);

    typedef Functor             functor_type;
    typedef std::tuple<Args...> args_type;

    typedef typename return_type_wrapper<ReturnType>::type result_type;

    typedef decltype(&Functor::operator ()) const type;

    template <std::size_t I>
    struct arguments {
        static_assert((I < arity), "Error: invalid parameter index.");
        using type = typename tuple_element_helper<I, Args...>::type;
    };

    typedef typename tuple_element_helper<0, Args...>::type arg0;
    typedef std::function<ReturnType(const Functor &, Args...)> func_type;
};

// Specialize for member object pointer
template <typename ReturnType, typename Functor>
struct function_traits<ReturnType(Functor::*)>
    /* : public function_traits<ReturnType(T &)> */ {
    static constexpr std::size_t arity = 0;

    typedef Functor      functor_type;
    typedef std::tuple<> args_type;

    typedef typename return_type_wrapper<ReturnType>::type result_type;

    typedef typename Functor::ReturnType * type;

    template <std::size_t I>
    struct arguments {
        using type = void_type;
    };

    typedef void_type arg0;
    typedef std::function<ReturnType(Functor &)> func_type;
};

// Specialize for std::function<T>
template <typename ReturnType, typename... Args>
struct function_traits<std::function<ReturnType(Args...)>>
    : public function_traits<ReturnType(Args...)> {
};

// Specialize for lambda or function object
template <typename Functor>
struct function_traits : public function_traits<decltype(&Functor::operator ())> {
};

template <typename Functor>
struct function_traits<Functor &> : public function_traits<Functor> {};

template <typename Functor>
struct function_traits<Functor &&> : public function_traits<Functor> {};

///////////////////////////////////////////////////////////////////////////////////////

} // namespace jstd

#endif // JSTD_FUNCTION_TRAITS_H

/***********************************************************************
  jstd\Variant.h
***********************************************************************/

#ifndef JSTD_VARIANT_H
#define JSTD_VARIANT_H

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#if !defined(_MSC_VER)
#include <cxxabi.h>
#endif
#include <assert.h>


#include <iostream>
#include <memory>
#include <typeinfo>
#include <typeindex>
#include <exception>
#include <stdexcept>


//
// See: https://www.cnblogs.com/qicosmos/p/3559424.html
// See: https://www.jianshu.com/p/f16181f6b18d
// See: https://en.cppreference.com/w/cpp/utility/variant
// See: https://github.com/mpark/variant/blob/master/include/mpark/variant.hpp
//

//
// C++ 17 std::variant
//
// https://zhuanlan.zhihu.com/p/498648144
//

namespace jstd {

// std::variant_npos
static constexpr std::size_t VariantNPos = (std::size_t)-1;

///////////////////////////////////////////////////////////////////////////////////////

// Like std::monostate
struct MonoState {
    MonoState() noexcept {}
    MonoState(const MonoState & src) noexcept {}

    template <typename T>
    MonoState(const T & src) noexcept {}

    ~MonoState() {}
};

#if (JSTD_IS_CPP_14 == 0)
bool operator == (MonoState, MonoState) noexcept { return true;  }
bool operator != (MonoState, MonoState) noexcept { return false; }
bool operator  < (MonoState, MonoState) noexcept { return false; }
bool operator  > (MonoState, MonoState) noexcept { return false; }
bool operator <= (MonoState, MonoState) noexcept { return true;  }
bool operator >= (MonoState, MonoState) noexcept { return true;  }
#else
constexpr bool operator == (MonoState, MonoState) noexcept { return true;  }
constexpr bool operator != (MonoState, MonoState) noexcept { return false; }
constexpr bool operator  < (MonoState, MonoState) noexcept { return false; }
constexpr bool operator  > (MonoState, MonoState) noexcept { return false; }
constexpr bool operator <= (MonoState, MonoState) noexcept { return true;  }
constexpr bool operator >= (MonoState, MonoState) noexcept { return true;  }
#endif

///////////////////////////////////////////////////////////////////////////////////////

// std::bad_variant_access
struct BadVariantAccess : public std::runtime_error {
    BadVariantAccess(const char * message = "Exception: Variant<Types...> Bad access") throw()
        : std::runtime_error(message) {
    }
    ~BadVariantAccess() noexcept {}
};

///////////////////////////////////////////////////////////////////////////////////////

template <std::size_t Val, std::size_t... Rest>
struct StaticMax;

template <std::size_t Val>
struct StaticMax<Val> : std::integral_constant<std::size_t, Val> {
};

template <std::size_t Val1, std::size_t Val2, std::size_t... Rest>
struct StaticMax<Val1, Val2, Rest...>
    : std::integral_constant<std::size_t, ((Val1 >= Val2) ?
                                           StaticMax<Val1, Rest...>::value :
                                           StaticMax<Val2, Rest...>::value) > {
};

template <typename... Types>
struct MaxAlign : std::integral_constant<std::size_t, StaticMax<std::alignment_of<Types>::value...>::value> {
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename T>
struct IsArray : std::is_array<T> {
};

template <typename T, std::size_t N>
struct IsArray<T[N]> : std::true_type {
};

template <typename T>
struct IsArray<T[]> : std::true_type {
};

template <typename T, std::size_t N>
struct IsArray<const T [N]> : std::true_type {
};

template <typename T>
struct IsArray<const T []> : std::true_type {
};

template <typename T, typename Base>
struct IsSame : std::is_same<T, Base> {
};

template <std::size_t N>
struct IsSame<char[N], char *> : std::true_type {
};

template <std::size_t N>
struct IsSame<const char[N], const char *> : std::true_type {
};

template <std::size_t N>
struct IsSame<wchar_t[N], wchar_t *> : std::true_type {
};

template <std::size_t N>
struct IsSame<const wchar_t[N], const wchar_t *> : std::true_type {
};

template <typename T, typename... Types>
struct ContainsType : std::true_type {
};

template <typename T, typename Head, typename... Types>
struct ContainsType<T, Head, Types...>
    : std::conditional<IsSame<T, Head>::value, std::true_type, ContainsType<T, Types...>>::type {
};

template <typename T>
struct ContainsType<T> : std::false_type {
};

///////////////////////////////////////////////////////////////////////////////////////

// Forward declaration
template <typename... Types>
class Variant;

// std::variant_size
template <typename T>
struct VariantSize;

template <typename T>
struct VariantSize<const T> : VariantSize<T> {
};

template <typename T>
struct VariantSize<volatile T> : VariantSize<T> {
};

template <typename T>
struct VariantSize<const volatile T> : VariantSize<T> {
};

// std::variant_size
template <typename... Types>
struct VariantSize<Variant<Types...>> : std::integral_constant<std::size_t, sizeof...(Types)> {
};

// Variable templates: require C++ 14 or MSVC 2015 update 3 and higher
#if defined(__cpp_variable_templates) || (defined(_MSC_VER) && (_MSC_FULL_VER >= 190024210))
template <typename T>
static constexpr std::size_t VariantSize_v = VariantSize<T>::value;
#endif

template <typename T>
using VariantSize_t = typename VariantSize<T>::type;

///////////////////////////////////////////////////////////////////////////////////////

// TypeIndexOf<T, I, ...>

template <typename T, std::size_t I, typename... Types>
struct TypeIndexOf {
};

template <typename T, std::size_t I, typename First, typename... Types>
struct TypeIndexOf<T, I, First, Types...> {
    static constexpr std::size_t value = TypeIndexOf<T, I + 1, Types...>::value;
};

template <typename T, std::size_t I, typename... Types>
struct TypeIndexOf<T, I, T, Types...> {
    static constexpr std::size_t value = I;
};

#if 1
template <std::size_t N, std::size_t I, typename... Types>
struct TypeIndexOf<char[N], I, char *, Types...> {
    static constexpr std::size_t value = I;
};

template <std::size_t N, std::size_t I, typename... Types>
struct TypeIndexOf<wchar_t[N], I, wchar_t *, Types...> {
    static constexpr std::size_t value = I;
};
#endif

#if 1
template <std::size_t N, std::size_t I, typename... Types>
struct TypeIndexOf<const char[N], I, const char *, Types...> {
    static constexpr std::size_t value = I;
};

template <std::size_t N, std::size_t I, typename... Types>
struct TypeIndexOf<const wchar_t[N], I, const wchar_t *, Types...> {
    static constexpr std::size_t value = I;
};
#endif

template <typename T, std::size_t I>
struct TypeIndexOf<T, I> {
    static constexpr std::size_t value = VariantNPos;
};

///////////////////////////////////////////////////////////////////////////////////////

// Forward declaration
template <typename T, typename... Types>
struct GetLeftSize;

// Declaration
template <typename T, typename First, typename... Types>
struct GetLeftSize<T, First, Types...> : GetLeftSize<T, Types...> {
};

// Specialized
template <typename T, typename... Types>
struct GetLeftSize<T, T, Types...> : std::integral_constant<std::size_t, sizeof...(Types)> {
};

template <typename T>
struct GetLeftSize<T> : std::integral_constant<std::size_t, 0> {
};

template <typename T, typename ...Types>
struct GetIndex : std::integral_constant<std::size_t, sizeof...(Types) - GetLeftSize<T, Types...>::value - 1> {
};

///////////////////////////////////////////////////////////////////////////////////////

// std::variant_alternative

// Forward declaration
template <std::size_t I, typename... Types>
struct VariantAlternative;

template <std::size_t I, typename T, typename... Types>
struct VariantAlternative<I, T, Types...> {
    static_assert((I < sizeof...(Types)),
                  "Error: index out of bounds in `jstd::VariantAlternative<>`");
    using type = typename VariantAlternative<I - 1, Types...>::type;
};

template <typename T, typename... Types>
struct VariantAlternative<0, T, Types...> {
    using type = T;
};

template <typename T, typename... Types>
struct VariantAlternative<0, const T, Types...> {
    using type = typename std::add_const<T>::type;
};

template <typename T, typename... Types>
struct VariantAlternative<0, volatile T, Types...> {
    using type = typename std::add_volatile<T>::type;
};

template <typename T, typename... Types>
struct VariantAlternative<0, const volatile T, Types...> {
    using type = typename std::add_cv<T>::type;
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename T>
struct TypeErasure {
    typedef typename std::remove_reference<T>::type _T0;

    typedef typename std::conditional<
                IsArray<_T0>::value,
                typename std::remove_extent<_T0>::type *,
                typename std::conditional<
                    std::is_function<_T0>::value,
                    typename std::add_pointer<_T0>::type,
                    typename std::remove_cv<_T0>::type
                >::type
            >::type   type;
};

template <typename T>
struct TypeErasureNoPtr {
    typedef typename std::remove_reference<T>::type _T0;

    typedef typename std::conditional<
                IsArray<_T0>::value,
                typename std::remove_extent<_T0>::type,
                typename std::conditional<
                    std::is_function<_T0>::value,
                    typename std::add_pointer<_T0>::type,
                    typename std::remove_cv<_T0>::type
                >::type
            >::type   type;
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename Visitor, typename Visitable, bool IsMoveSemantics>
class void_visit_invoke {
public:
    typedef typename function_traits<Visitor>::result_type result_type;

private:
    Visitor &   visitor_;
    Visitable & visitable_;

public:
    void_visit_invoke(Visitor & visitor, Visitable & visitable) noexcept
        : visitor_(visitor), visitable_(visitable) {
    }

    void_visit_invoke(Visitor && visitor, Visitable && visitable) noexcept
        : visitor_(std::forward<Visitor>(visitor)), visitable_(std::forward<Visitable>(visitable)) {
    }

    void_visit_invoke & operator () (void) const {
        return *this;
    }

    template <typename Visitable2>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value), void>::type
    operator () (Visitable2 & visitable) {
        visitable_.move_visit(visitor_);
    }

    template <typename Visitable2>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value), void>::type
    operator () (Visitable2 & visitable) {
        visitable_.no_move_visit(visitor_);
    }

private:
    void_visit_invoke & operator = (const void_visit_invoke &);
};

template <typename Visitor, typename Visitable, bool IsMoveSemantics>
class result_visit_invoke {
public:
    typedef typename function_traits<Visitor>::result_type result_type;

private:
    Visitor &   visitor_;
    Visitable & visitable_;

public:
    result_visit_invoke(Visitor & visitor, Visitable & visitable) noexcept
        : visitor_(visitor), visitable_(visitable) {
    }

    result_visit_invoke(Visitor && visitor, Visitable && visitable) noexcept
        : visitor_(std::forward<Visitor>(visitor)), visitable_(std::forward<Visitable>(visitable)) {
    }

    template <typename Visitable2>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value),
                            typename function_traits<Visitor>::result_type>::type
    operator () (Visitable2 & visitable) {
        return visitable_.move_visit(visitor_);
    }

    template <typename Visitable2>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value),
                            typename function_traits<Visitor>::result_type>::type
    operator () (Visitable2 & visitable) {
        return visitable_.no_move_visit(visitor_);
    }

private:
    result_visit_invoke & operator = (const result_visit_invoke &);
};

template <typename Visitor, typename Visitable, bool IsMoveSemantics>
class void_visitor_wrapper {
public:
    typedef typename function_traits<Visitor>::result_type result_type;

private:
    Visitor &   visitor_;
    Visitable & visitable_;

public:
    void_visitor_wrapper(Visitor & visitor, Visitable & visitable) noexcept
        : visitor_(visitor), visitable_(visitable) {
    }

    void_visitor_wrapper(Visitor && visitor, Visitable && visitable) noexcept
        : visitor_(std::forward<Visitor>(visitor)), visitable_(std::forward<Visitable>(visitable)) {
    }

    template <typename Visitable2>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value), void>::type
    operator () (Visitable2 && visitable) {
        visitor_(std::move(visitable_));
    }

    template <typename Visitable2>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value), void>::type
    operator () (Visitable2 && visitable) {
        visitor_(visitable_);
    }

private:
    void_visitor_wrapper & operator = (const void_visitor_wrapper &);
};

template <typename Visitor, typename Visitable, bool IsMoveSemantics>
class result_visitor_wrapper {
public:
    typedef typename function_traits<Visitor>::result_type result_type;

    typedef typename std::remove_reference<Visitor>::type   visitor_t;
    typedef typename std::remove_reference<Visitable>::type visitable_t;

private:
    visitor_t &   visitor_;
    visitable_t & visitable_;

public:
    result_visitor_wrapper(visitor_t & visitor, visitable_t & visitable) noexcept
        : visitor_(visitor), visitable_(visitable) {
    }

    result_visitor_wrapper(visitor_t && visitor, visitable_t && visitable) noexcept
        : visitor_(std::forward<visitor_t>(visitor)), visitable_(std::forward<visitable_t>(visitable)) {
    }

    template <typename Visitable2>
    typename std::enable_if<(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value),
                            typename function_traits<Visitor>::result_type>::type
    operator () (Visitable2 && visitable) {
        return visitor_(std::move(visitable_));
    }

    template <typename Visitable2>
    typename std::enable_if<!(IsMoveSemantics && std::is_same<Visitable2, Visitable2>::value),
                            typename function_traits<Visitor>::result_type>::type
    operator () (Visitable2 && visitable) {
        return visitor_(visitable_);
    }

private:
    result_visitor_wrapper & operator = (const result_visitor_wrapper &);
};

///////////////////////////////////////////////////////////////////////////////////////

/*
  std::size_t kMask = (std::is_integral<T>::value ?
                      (!std::is_pointer<T>::value ? 0 : 1) :
                      (!std::is_pointer<T>::value ? 2 : 3));
*/
template <typename T, std::size_t Mask>
struct MathHelper;

template <typename T>
struct MathHelper<T, std::size_t(0)> {
    static T add(T a, T b) {
        return (a + b);
    }

    static T sub(T a, T b) {
        return (a - b);
    }
};

template <>
struct MathHelper<bool, std::size_t(0)> {
    static bool add(bool a, bool b) {
        return (a || b);
    }

    static bool sub(bool a, bool b) {
        return (a && b);
    }
};

template <typename T>
struct MathHelper<T, std::size_t(1)> {
    static T add(T a, T b) {
        T tmp(a);
        return tmp;
    }

    static T sub(T a, T b) {
        T tmp(a);
        return tmp;
    }
};

template <typename T>
struct MathHelper<T, std::size_t(2)> {
    static T add(const T & a, const T & b) {
        return (a + b);
    }

    static T sub(const T & a, const T & b) {
        return (a - b);
    }
};

template <typename T>
struct MathHelper<T, std::size_t(3)> {
    static T add(T a, T b) {
        T tmp(a);
        return tmp;
    }

    static T sub(T a, T b) {
        T tmp(a);
        return tmp;
    }
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename... Types>
struct VariantHelper;

template <typename T, typename... Types>
struct VariantHelper<T, Types...> {
    static inline
    void destroy(std::type_index type_id, void * data) {
        if (type_id == std::type_index(typeid(T)))
            reinterpret_cast<T *>(data)->~T();
        else
            VariantHelper<Types...>::destroy(type_id, data);
    }

    static inline
    void copy(std::type_index old_type, const void * old_val, void * new_val) {
        if (old_type == std::type_index(typeid(T)))
            new (new_val) T(*reinterpret_cast<const T *>(old_val));
        else
            VariantHelper<Types...>::copy(old_type, old_val, new_val);
    }

    static inline
    void move(std::type_index old_type, void * old_val, void * new_val) {
        if (old_type == std::type_index(typeid(T)))
            new (new_val) T(std::move(*reinterpret_cast<T *>(old_val)));
        else
            VariantHelper<Types...>::move(old_type, old_val, new_val);
    }

    static inline
    void swap(std::type_index old_type, void * old_val, void * new_val) {
        if (old_type == std::type_index(typeid(T)))
            std::swap(*reinterpret_cast<T *>(new_val), *reinterpret_cast<T *>(old_val));
        else
            VariantHelper<Types...>::swap(old_type, old_val, new_val);
    }

    static inline
    int compare(std::type_index type_idx, void * left_val, void * right_val) {
        if (type_idx == std::type_index(typeid(T))) {
            if (*reinterpret_cast<T *>(left_val) > *reinterpret_cast<T *>(right_val))
                return 1;
            else if (*reinterpret_cast<T *>(left_val) < *reinterpret_cast<T *>(right_val))
                return -1;
            else
                return 0;
        } else {
            return VariantHelper<Types...>::compare(type_idx, left_val, right_val);
        }
    }

    static inline
    void add(std::type_index type_idx, const void * left_val, const void * right_val, void * out_val) {
        if (type_idx == std::type_index(typeid(T))) {
            typedef typename std::remove_cv<T>::type U;
            const U & left  = (*reinterpret_cast<U *>(const_cast<void *>(left_val)));
            const U & right = (*reinterpret_cast<U *>(const_cast<void *>(right_val)));
            static constexpr std::size_t kMask = (std::is_integral<T>::value ?
                                                 (!std::is_pointer<T>::value ? 0 : 1) :
                                                 (!std::is_pointer<T>::value ? 2 : 3));
            U sum = MathHelper<U, kMask>::add(left, right);
            *reinterpret_cast<U *>(out_val) = std::move(sum);
        }
        else {
            VariantHelper<Types...>::add(type_idx, left_val, right_val, out_val);
        }
    }

    static inline
    void sub(std::type_index type_idx, const void * left_val, const void * right_val, void * out_val) {
        if (type_idx == std::type_index(typeid(T))) {
            typedef typename std::remove_cv<T>::type U;
            const U & left  = (*reinterpret_cast<U *>(const_cast<void *>(left_val)));
            const U & right = (*reinterpret_cast<U *>(const_cast<void *>(right_val)));
            static constexpr std::size_t kMask = (std::is_integral<T>::value ?
                                                 (!std::is_pointer<T>::value ? 0 : 1) :
                                                 (!std::is_pointer<T>::value ? 2 : 3));
            U sub = MathHelper<U, kMask>::sub(left, right);
            *reinterpret_cast<U *>(out_val) = std::move(sub);
        }
        else {
            VariantHelper<Types...>::sub(type_idx, left_val, right_val, out_val);
        }
    }

    template <typename ResultType, typename Visitor>
    static inline
    void apply_visitor(std::type_index type_idx, void * data, ResultType * result, Visitor & visitor) {
        if (type_idx == std::type_index(typeid(T))) {
            *result = visitor(*reinterpret_cast<T *>(data));
        } else {
            VariantHelper<Types...>::template apply_visitor<ResultType, Visitor>(
                type_idx, data, result, visitor);
        }
    }

    template <typename ResultType, typename Visitor>
    static inline
    void apply_move_visitor(std::type_index type_idx, void * data, ResultType * result, Visitor && visitor) {
        if (type_idx == std::type_index(typeid(T))) {
            *result = visitor(*reinterpret_cast<T *>(data));
        } else {
            VariantHelper<Types...>::template apply_move_visitor<ResultType, Visitor>(
                type_idx, data, result, std::forward<Visitor>(visitor));
        }
    }
};

template <>
struct VariantHelper<>  {
    static inline void destroy(std::type_index type_idx, void * data) {}
    static inline void copy(std::type_index old_type, const void * old_val, void * new_val) {}
    static inline void move(std::type_index old_type, void * old_val, void * new_val) {}
    static inline void swap(std::type_index old_type, void * old_val, void * new_val) {}

    static inline void compare(std::type_index type_idx, void * left_val, void * right_val) {}

    static inline void add(std::type_index type_idx, const void * left_val, const void * right_val, void * out_val) {}
    static inline void sub(std::type_index type_idx, const void * left_val, const void * right_val, void * out_val) {}

    template <typename ResultType, typename Visitor>
    static inline
    void apply_visitor(std::type_index type_idx, void * data, ResultType * result, Visitor & visitor) {}

    template <typename ResultType, typename Visitor>
    static inline
    void apply_move_visitor(std::type_index type_idx, void * data, ResultType * result, Visitor && visitor) {}
};

///////////////////////////////////////////////////////////////////////////////////////

struct is_variant_tag {
};

template <typename T>
struct is_variant : public std::integral_constant<bool, std::is_base_of<is_variant_tag, T>::value> {
};

template <typename... Types>
class Variant : public is_variant_tag {
public:
    typedef Variant<Types...>           this_type;
    typedef VariantHelper<Types...>     helper_type;

    enum {
        kDataSize  = StaticMax<sizeof(Types)...>::value,
        kAlignment = MaxAlign<Types...>::value
    };
    using data_t = typename std::aligned_storage<kDataSize, kAlignment>::type;

    typedef std::size_t size_type;

    static constexpr size_type kMaxType = sizeof...(Types);

protected:
    data_t          data_;
    size_type       index_;
    std::type_index type_index_;

public:
    Variant() noexcept : index_(VariantNPos), type_index_(typeid(void)) {
    }

    template <typename T,
              typename = typename std::enable_if<ContainsType<typename std::remove_reference<T>::type, Types...>::value>::type>
    Variant(const T & value) : index_(VariantNPos), type_index_(typeid(void)) {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("Variant(const T & value)");

        new (&this->data_) U(value);
        this->index_ = this->index_of<U>();
        this->type_index_ = typeid(U);
    }

    template <typename T,
              typename = typename std::enable_if<ContainsType<typename std::remove_reference<T>::type, Types...>::value>::type>
    Variant(T && value) : index_(VariantNPos), type_index_(typeid(void)) {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("Variant(T && value)");

        new (&this->data_) U(std::forward<T>(value));
        this->index_ = this->index_of<U>();
        this->type_index_ = typeid(U);
    }

    template <typename T, size_type N>
    Variant(T (&value)[N]) : index_(VariantNPos), type_index_(typeid(void)) {
        typedef typename std::remove_volatile<T>::type * U;
        this->print_type_info<T, U>("Variant(T (&value)[N])", false);

        new (&this->data_) U(value);
        this->index_ = this->index_of<U>();
        this->type_index_ = typeid(U);
    }

    template <typename T, size_type N>
    Variant(const T (&value)[N]) : index_(VariantNPos), type_index_(typeid(void)) {
        typedef typename std::add_const<typename std::remove_volatile<T>::type>::type * U;
        this->print_type_info<T, U>("Variant(const T (&value)[N])", false);

        new (&this->data_) U(value);
        this->index_ = this->index_of<U>();
        this->type_index_ = typeid(U);
    }

#if 0
    template <typename T, typename... Args>
    Variant(const T & type, Args &&... args) : index_(VariantNPos), type_index_(typeid(void)) {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("Variant(const T & type, Args &&... args)");

        static constexpr bool is_constructible = std::is_constructible<T, Args...>::value;
        if (is_constructible) {
            new (&this->data_) U(std::forward<Args>(args)...);
            this->index_ = this->index_of<U>();
            this->type_index_ = typeid(U);
        } else {
            throw BadVariantAccess("Exception: Bad emplace assignment access.");
        }

        //static_assert(is_constructible, "Error: Bad emplace assignment access.");
    }
#endif

    Variant(const this_type & other) : index_(other.index_), type_index_(other.type_index_) {
        helper_type::copy(other.type_index_, (void *)&other.data_, (void *)&this->data_);
    }

    Variant(this_type && other) : index_(other.index_), type_index_(other.type_index_) {
        helper_type::move(other.type_index_, (void *)&other.data_, (void *)&this->data_);
        other.index_ = VariantNPos;
        other.type_index_ = typeid(void);
    }

    Variant(const jstd::void_type & other) noexcept : index_(VariantNPos), type_index_(typeid(void)) {
    }

    Variant(jstd::void_type && other) noexcept : index_(VariantNPos), type_index_(typeid(void)) {
    }

    virtual ~Variant() {
        this->destroy();
    }

protected:
    inline void destroy() {
        helper_type::destroy(this->type_index_, (void *)&this->data_);
        this->index_ = VariantNPos;
        this->type_index_ = typeid(void);
    }

private:
    template <typename T, typename U>
    inline void print_type_info(const std::string & title, bool T_is_main = true) const {
#ifdef _DEBUG
        if (0) {
            printf("%s;\n\n", title.c_str());
            printf("typeid(T).name() = %s\n", typeid(T).name());
            printf("typeid(U).name() = %s\n", typeid(U).name());
            printf("typeid(std::remove_const<T>::type).name() = %s\n", typeid(typename std::remove_const<T>::type).name());
            if (T_is_main) {
                printf("ContainsType<T>::value = %u\n", (uint32_t)ContainsType<typename std::remove_reference<T>::type, Types...>::value);
                printf("std::is_array<T>::value = %u\n", (uint32_t)std::is_array<typename std::remove_const<T>::type>::value);
                printf("IsArray<T>::value = %u\n", (uint32_t)IsArray<T>::value);
            } else {
                printf("ContainsType<U>::value = %u\n", (uint32_t)ContainsType<typename jstd::TypeErasure<U>::type, Types...>::value);
                printf("std::is_array<U>::value = %u\n", (uint32_t)std::is_array<typename std::remove_const<U>::type>::value);
                printf("IsArray<U>::value = %u\n", (uint32_t)IsArray<U>::value);
            }
            printf("\n");
        }
#endif
    }

    template <typename T>
    inline void check_valid_type(const char * name) const {
        if (!this->holds_alternative<T>()) {
            std::cout << "Variant<Types...>::" << name << " exception:" << std::endl << std::endl;
            std::cout << "Type [" << typeid(T).name() << "] is not defined. " << std::endl;
            std::cout << "Current type is [" << this->type().name() << "], index is "
                      << (std::intptr_t)this->index() << "." << std::endl << std::endl;
            throw BadVariantAccess();
        }
    }

    template <typename T>
    inline void check_valid_type(char * name) const {
        return this->check_valid_type<T>((const char *)name);
    }

public:
    this_type & operator = (const this_type & rhs) {
        // For the safety of exceptions, reset the index and type index.
        this->destroy();

        helper_type::copy(rhs.type_index_, (void *)&rhs.data_, (void *)&this->data_);
        this->index_ = rhs.index_;
        this->type_index_ = rhs.type_index_;
        return *this;
    }

    this_type & operator = (this_type && rhs) {
        // For the safety of exceptions, reset the index and type index.
        this->destroy();

        helper_type::move(rhs.type_index_, (void *)&rhs.data_, (void *)&this->data_);
        this->index_ = rhs.index_;
        this->type_index_ = rhs.type_index_;

        // Reset the rhs index
        rhs.index_ = VariantNPos;
        rhs.type_index_ = typeid(void);
        return *this;
    }

    template <typename T, typename... Args>
    T & emplace(Args &&... args) {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("T & Variant::emplace(Args &&... args)");

        static constexpr bool is_constructible = std::is_constructible<T, Args...>::value;
        if (is_constructible) {
            // For the safety of exceptions, reset the index and type index.
            this->destroy();

            new (&this->data_) U(std::forward<Args>(args)...);
            this->index_ = this->index_of<U>();
            this->type_index_ = typeid(U);
        } else {
            throw BadVariantAccess("Exception: Bad emplace assignment access.");
        }

        //static_assert(is_constructible, "Error: Bad Variant::emplace(Args &&... args) access.");

        return *(reinterpret_cast<T *>(this->data_));
    }

    template <typename T, typename... Args>
    const T & emplace(Args &&... args) const {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("const T & Variant::emplace(Args &&... args)");

        static constexpr bool is_constructible = std::is_constructible<T, Args...>::value;
        if (is_constructible) {
            // For the safety of exceptions, reset the index and type index.
            this->destroy();

            new (&this->data_) U(std::forward<Args>(args)...);
            this->index_ = this->index_of<U>();
            this->type_index_ = typeid(U);
        } else {
            throw BadVariantAccess("Exception: Bad emplace assignment access.");
        }

        //static_assert(is_constructible, "Error: Bad Variant::emplace(Args &&... args) access.");

        return *(const_cast<const T *>(reinterpret_cast<T *>(this->data_)));
    }

    template <typename T, typename V, typename... Args>
    T & emplace(std::initializer_list<V> il, Args &&... args) {
        typedef typename std::remove_reference<T>::type U;
        this->print_type_info<T, U>("T & Variant::emplace(std::initializer_list<V> il, Args &&... args)");

        static constexpr bool is_constructible = std::is_constructible<T, std::initializer_list<V> &, Args...>::value;
        if (is_constructible) {
            // For the safety of exceptions, reset the index and type index.
            this->destroy();

            new (&this->data_) U(il, std::forward<Args>(args)...);
            this->index_ = this->index_of<U>();
            this->type_index_ = typeid(U);
        } else {
            throw BadVariantAccess("Exception: Bad emplace assignment access.");
        }

        //static_assert(is_constructible, "Error: Bad Variant::emplace(std::initializer_list<V> il, Args &&... args) access.");

        return *(reinterpret_cast<T *>(this->data_));
    }

    this_type add(const this_type & rhs) const  {
        this_type tmp(*this);
        if ((this->index() == rhs.index()) &&
            !this->valueless_by_exception() &&
            !rhs.valueless_by_exception()) {
            helper_type::add(this->type_index_, (const void *)&this->data_,
                             (const void *)&rhs.data_, (void *)&tmp.data_);
        }
        return tmp;
    }

    this_type sub(const this_type & rhs) const  {
        this_type tmp(*this);
        if ((this->index() == rhs.index()) &&
            !this->valueless_by_exception() &&
            !rhs.valueless_by_exception()) {
            helper_type::sub(this->type_index_, (const void *)&this->data_,
                             (const void *)&rhs.data_, (void *)&tmp.data_);
        }
        return tmp;
    }

    this_type operator + (const this_type & rhs) const {
        return this->add(rhs);
    }

    this_type operator - (const this_type & rhs) const {
        return this->sub(rhs);
    }

    bool operator == (const this_type & rhs) const {
        if (this->index_ == rhs.index_) {
            int cmp = helper_type::compare(this->type_index_, (void *)&this->data_, (void *)&rhs.data_);
            return (cmp == 0);
        }
        return false;
    }

    bool operator != (const this_type & rhs) const {
        if (this->index_ != rhs.index_) {
            return true;
        } else {
            int cmp = helper_type::compare(this->type_index_, (void *)&this->data_, (void *)&rhs.data_);
            return (cmp != 0);
        }
    }

    bool operator < (const this_type & rhs) const {
        if (this->index_ == rhs.index_) {
            int cmp = helper_type::compare(this->type_index_, (void *)&this->data_, (void *)&rhs.data_);
            return (cmp < 0);
        }
        return (this->index_ < rhs.index_);
    }

    bool operator > (const this_type & rhs) const {
        if (this->index_ == rhs.index_) {
            int cmp = helper_type::compare(this->type_index_, (void *)&this->data_, (void *)&rhs.data_);
            return (cmp > 0);
        }
        return (this->index_ > rhs.index_);
    }

    bool operator <= (const this_type & rhs) const {
        return !(*this > rhs);
    }

    bool operator >= (const this_type & rhs) const {
        return !(*this < rhs);
    }

    constexpr size_type size() const noexcept {
        return sizeof...(Types);
    }

    size_type index() const noexcept {
        return this->index_;
    }

    std::type_index & type() noexcept {
        return this->type_index_;
    }

    const std::type_index type() const noexcept {
        return this->type_index_;
    }

    template <typename T>
    bool is_type() const {
        return (this->type_index_ == typeid(T));
    }

    inline bool has_assigned() const noexcept {
#if 1
        size_type index = this->index();
        return (index != VariantNPos);
#else
        return (this->type_index_ != type_index(typeid(void)));
#endif
    }

    inline bool valueless_by_exception() const noexcept {
        size_type index = this->index();
        return (index >= this->size() || index == VariantNPos);
    }

    inline bool is_valid_index() const noexcept {
        size_type index = this->index();
        return (index < this->size() && index != VariantNPos);
    }

    static inline
    constexpr bool is_valid_index(size_type index) noexcept {
        return (index < kMaxType && index != VariantNPos);
    }

    template <typename T>
    inline bool is_valid_type_index() const noexcept {
        using U = typename std::remove_reference<T>::type;
        if (this->type_index_ == std::type_index(typeid(U))) {
            return this->is_valid_index();
        } else {
            return false;
        }
    }

    template <typename T>
    static inline
    constexpr size_type index_of() noexcept {
        using U = typename std::remove_reference<T>::type;
        return TypeIndexOf<U, 0, Types...>::value;
    }

    template <typename T>
    inline bool holds_alternative() const noexcept {
        using U = typename std::remove_reference<T>::type;
        constexpr size_type index = this->index_of<U>();
        if (index == this->index()) {
            return this->is_valid_index();
        } else {
            return false;
        }
    }

    // Using abi demangle to print nice type name of instance of any holding.
    std::string pretty_type() {
        std::string strType;
#if defined(_MSC_VER)
        strType = this->type_index_.name();
#else
        int status;
        if (char * p = abi::__cxa_demangle(this->type_index_.name(), 0, 0, &status)) {
            strType = p;
            std::free(p);
        }
#endif
        return strType;
    }

    template <size_type I>
    void init() {
        if (this->index_ == VariantNPos) {
            using T = typename VariantAlternative<I, Types...>::type;
            typedef typename std::remove_reference<T>::type U;
            if (this->holds_alternative<U>()) {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();

                new (&this->data_) U();
                this->index_ = I;
                this->type_index_ = typeid(U);
            }
        }
    }

    template <typename T>
    typename std::remove_reference<T>::type & get() {
        using U = typename std::remove_reference<T>::type;
        this->check_valid_type<U>("T & get<T>()");
        return *((U *)(&this->data_));
    }

    template <typename T>
    const typename std::remove_reference<T>::type & get() const {
        using U = typename std::remove_reference<T>::type;
        this->check_valid_type<U>("const T & get<T>()");
        return *((const U *)(&this->data_));
    }

#if 0
    template <typename T>
    typename std::remove_reference<T>::type && get() {
        using U = typename std::remove_reference<T>::type;
        this->check_valid_type<U>("T && get<T>()");
        return std::move(*((U *)(&this->data_)));
    }

    template <typename T>
    const typename std::remove_reference<T>::type && get() const {
        using U = typename std::remove_reference<T>::type;
        this->check_valid_type<U>("const T && get<T>()");
        return std::move(*((const U *)(&this->data_)));
    }
#endif

    template <size_type I>
    typename VariantAlternative<I, Types...>::type & get() {
        using U = typename VariantAlternative<I, Types...>::type;
        this->check_valid_type<U>("T & get<I>()");
        return *((U *)(&this->data_));
    }

    template <size_type I>
    const typename VariantAlternative<I, Types...>::type & get() const {
        using U = typename VariantAlternative<I, Types...>::type;
        this->check_valid_type<U>("const T & get<I>()");
        return *((const U *)(&this->data_));
    }

#if 0
    template <size_type I>
    typename VariantAlternative<I, Types...>::type && get() {
        using U = typename VariantAlternative<I, Types...>::type;
        this->check_valid_type<U>("T && get<I>()");
        return std::move(*((U *)(&this->data_)));
    }

    template <size_type I>
    const typename VariantAlternative<I, Types...>::type && get() const {
        using U = typename VariantAlternative<I, Types...>::type;
        this->check_valid_type<U>("const T && get<I>()");
        return std::move(*((const U *)(&this->data_)));
    }
#endif

    template <typename T>
    void set(const T & value) {
        using U = typename std::remove_reference<T>::type;
        size_type new_index = this->index_of<U>();
        if (this->has_assigned()) {
            if (new_index == this->index()) {
                assert(new_index == this->index_);
                assert(typeid(U) == this->type_index_);
                *((U *)(&this->data_)) = value;
                return;
            } else {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();
            }
        }

        new (&this->data_) U(value);
        this->index_ = new_index;
        this->type_index_ = typeid(U);
    }

    template <typename T>
    void set(T && value) {
        using U = typename std::remove_reference<T>::type;
        size_type new_index = this->index_of<U>();
        if (this->has_assigned()) {
            if (new_index == this->index()) {
                assert(new_index == this->index_);
                //assert(typeid(U) == this->type_index_);
                *((U *)(&this->data_)) = std::forward<U>(value);
                return;
            } else {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();
            }
        }

        new (&this->data_) U(std::forward<T>(value));
        this->index_ = new_index;
        this->type_index_ = typeid(U);
    }

    template <typename T, size_type N>
    void set(T (&value)[N]) {
        using U = typename std::remove_reference<T>::type *;
        size_type new_index = this->index_of<U>();
        if (this->has_assigned()) {
            if (new_index == this->index()) {
                assert(new_index == this->index_);
                //assert(typeid(U) == this->type_index_);
                *((U *)(&this->data_)) = value;
                return;
            } else {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();
            }
        }

        new (&this->data_) U(value);
        this->index_ = new_index;
        this->type_index_ = typeid(U);
    }

    template <size_type I>
    void set(const typename VariantAlternative<I, Types...>::type & value) {
        using U = typename std::remove_reference<typename VariantAlternative<I, Types...>::type>::type;
        size_type new_index = this->index_of<U>();
        if (this->has_assigned()) {
            if (new_index == this->index()) {
                assert(new_index == this->index_);
                assert(typeid(U) == this->type_index_);
                *((U *)(&this->data_)) = value;
                return;
            } else {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();
            }
        }

        new (&this->data_) U(value);
        this->index_ = new_index;
        this->type_index_ = typeid(U);
    }

    template <size_type I>
    void set(typename VariantAlternative<I, Types...>::type && value) {
        using T = typename VariantAlternative<I, Types...>::type;
        using U = typename std::remove_reference<typename VariantAlternative<I, Types...>::type>::type;
        size_type new_index = this->index_of<U>();
        if (this->has_assigned()) {
            if (new_index == this->index()) {
                assert(new_index == this->index_);
                assert(typeid(U) == this->type_index_);
                *((U *)(&this->data_)) = std::forward<U>(value);
                return;
            } else {
                // For the safety of exceptions, reset the index and type index.
                this->destroy();
            }
        }

        new (&this->data_) U(std::forward<T>(value));
        this->index_ = new_index;
        this->type_index_ = typeid(U);
    }

    template <typename Visitor>
    typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            typename function_traits<Visitor>::result_type>::type
    move_visit(Visitor && visitor) {
        using result_type  = typename function_traits<Visitor>::result_type;
        using result_type_ = typename std::remove_cv<typename std::remove_reference<result_type>::type>::type;
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<result_type_, this_type>::value) {
            if (std::is_same<Arg0_, this_type>::value) {
                *this = std::forward<Visitor>(visitor)(std::move(*this));
            } else if (this->holds_alternative<Arg0T>()) {
                *this = std::forward<Visitor>(visitor)(std::move(this->get<Arg0T>()));
            }
            return *this;
        } else {
            result_type result;
            if (std::is_same<Arg0_, this_type>::value) {
                result = std::forward<Visitor>(visitor)(std::move(*this));
            } else if (this->holds_alternative<Arg0T>()) {
                result = std::forward<Visitor>(visitor)(std::move(this->get<Arg0T>()));
            }
            return result;
        }
    }

    template <typename Visitor>
    typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            typename function_traits<Visitor>::result_type>::type
    no_move_visit(Visitor && visitor) {
        using result_type  = typename function_traits<Visitor>::result_type;
        using result_type_ = typename std::remove_cv<typename std::remove_reference<result_type>::type>::type;
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<result_type_, this_type>::value) {
            if (std::is_same<Arg0_, this_type>::value) {
                *this = std::forward<Visitor>(visitor)(*this);
            } else if (this->holds_alternative<Arg0T>()) {
                *this = std::forward<Visitor>(visitor)(this->get<Arg0T>());
            }
            return *this;
        } else {
            result_type result;
            if (std::is_same<Arg0_, this_type>::value) {
                result = std::forward<Visitor>(visitor)(*this);
            } else if (this->holds_alternative<Arg0T>()) {
                result = std::forward<Visitor>(visitor)(this->get<Arg0T>());
            }
            return result;
        }
    }

    template <typename Visitor>
    typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            typename function_traits<Visitor>::result_type>::type
    visit(Visitor && visitor) {
        using result_type  = typename function_traits<Visitor>::result_type;
        using result_type_ = typename std::remove_cv<typename std::remove_reference<result_type>::type>::type;
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isVisitorMoveSemantics = !std::is_lvalue_reference<Visitor>::value;
        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<result_type_, this_type>::value) {
            if (std::is_same<Arg0_, this_type>::value) {
                result_visit_invoke<Visitor, this_type, isMoveSemantics> invoker(visitor, *this);
                *this = invoker(*this);
            } else if (this->holds_alternative<Arg0T>()) {
                result_visit_invoke<Visitor, Arg0T, isMoveSemantics> invoker(visitor, this->get<Arg0T>());
                *this = invoker(this->get<Arg0T>());
            }
            return *this;
        } else {
            result_type result;
            if (std::is_same<Arg0_, this_type>::value) {
                result_visit_invoke<Visitor, this_type, isMoveSemantics> invoker(visitor, *this);
                result = invoker(*this);
            } else if (this->holds_alternative<Arg0T>()) {
                result_visit_invoke<Visitor, Arg0T, isMoveSemantics> invoker(visitor, this->get<Arg0T>());
                result = invoker(this->get<Arg0T>());
            }
            return result;
        }
    }

    template <typename Visitor, typename First, typename... Args>
    typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            typename function_traits<Visitor>::result_type>::type
    visit(Visitor && visitor, First && first, Args &&... args) {
        using result_type  = typename function_traits<Visitor>::result_type;
        using result_type_ = typename std::remove_cv<typename std::remove_reference<result_type>::type>::type;
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;
        using FirstT = typename std::remove_reference<First>::type;
        using First_ = typename std::remove_cv<FirstT>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<First>::value;

        result_type result;
#if 1
        if (std::is_same<First_, this_type>::value || ::jstd::is_variant<First_>::value) {
            std::forward<First>(first).visit(std::forward<Visitor>(visitor));
        } else if (std::is_same<Arg0_, result_type_>::value) {
            first = std::forward<Visitor>(visitor)(std::move(std::forward<First>(first)));
        } else {
            std::forward<Visitor>(visitor)(std::move(std::forward<First>(first)));
        }
#else
        if (std::is_same<First_, this_type>::value || ::jstd::is_variant<First_>::value) {
            std::forward<First>(first).visit(std::forward<Visitor>(visitor));
        } else if (std::is_same<Arg0_, result_type_>::value) {
            result_visitor_wrapper<Visitor, FirstT, true> wrapper(visitor, first);
            first = wrapper(std::forward<First>(first));
        } else {
            result_visitor_wrapper<Visitor, FirstT, true> wrapper(visitor, first);
            wrapper(std::forward<First>(first));
        }
#endif
        result = this->visit(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
        return result;
    }

    template <typename Visitor>
    typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            void>::type
    move_visit(Visitor && visitor) {
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<Arg0_, this_type>::value) {
            std::forward<Visitor>(visitor)(std::move(*this));
        } else if (this->holds_alternative<Arg0T>()) {
            std::forward<Visitor>(visitor)(std::move(this->get<Arg0T>()));
        }
    }

    template <typename Visitor>
    typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            void>::type
    no_move_visit(Visitor && visitor) {
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<Arg0_, this_type>::value) {
            std::forward<Visitor>(visitor)(*this);
        } else if (this->holds_alternative<Arg0T>()) {
            std::forward<Visitor>(visitor)(this->get<Arg0T>());
        }
    }

    template <typename Visitor>
    typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            void>::type
    visit(Visitor && visitor) {
        using Arg0 = typename function_traits<Visitor>::arg0;
        using Arg0T = typename std::remove_reference<Arg0>::type;
        using Arg0_ = typename std::remove_cv<Arg0T>::type;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg0>::value;

        if (std::is_same<Arg0_, this_type>::value) {
            void_visit_invoke<Visitor, this_type, isMoveSemantics> invoker(visitor, *this);
            invoker(*this);
        } else if (this->holds_alternative<Arg0T>()) {
            void_visit_invoke<Visitor, Arg0T, isMoveSemantics> invoker(visitor, this->get<Arg0T>());
            invoker(this->get<Arg0T>());
        }
    }

    template <typename Visitor, typename First, typename... Args>
    typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                            void>::type
    visit(Visitor && visitor, First && first, Args &&... args) {
        using FirstT = typename std::remove_reference<First>::type;
        using First_ = typename std::remove_cv<FirstT>::type;

        if (std::is_same<First_, this_type>::value || ::jstd::is_variant<First_>::value) {
            std::forward<First>(first).visit(std::forward<Visitor>(visitor));
        } else {
            std::forward<Visitor>(visitor)(std::move(std::forward<First>(first)));
        }
        this->visit(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
    }

    template <typename Visitor>
    inline
    typename std::enable_if<!std::is_const<Visitor>::value,
                            typename detail::return_type_wrapper<
                                typename Visitor::result_type
                              >::type
                           >::type
    apply_visitor(Visitor & visitor) {
        using result_type = typename Visitor::result_type;
        result_type result;
        static constexpr size_type index = this_type::index_of<result_type>();
        if (this_type::is_valid_index(index)) {
            result = visitor((this->template get<result_type>()));
        } else if (this->holds_alternative<result_type>() || std::is_same<result_type, this_type>::value) {
            helper_type::template apply_visitor<result_type, Visitor>(
                this->type_index_, (void *)&this->data_, &result, visitor);
        }
        return result;
    }

    template <typename Visitor>
    inline
    typename std::enable_if<!std::is_const<Visitor>::value,
                            typename detail::return_type_wrapper<
                                typename Visitor::result_type
                              >::type
                           >::type
    apply_visitor(Visitor && visitor) {
        using result_type = typename Visitor::result_type;
        result_type result;
        static constexpr size_type index = this_type::index_of<result_type>();
        if (this_type::is_valid_index(index)) {
            result = std::forward<Visitor>(visitor)((this->template get<result_type>()));
        } else if (this->holds_alternative<result_type>() || std::is_same<result_type, this_type>::value) {
            helper_type::template apply_move_visitor<result_type, Visitor>(
                this->type_index_, (void *)&this->data_, &result, std::forward<Visitor>(visitor));
        }
        return result;
    }

    template <typename Visitor>
    inline
    typename detail::return_type_wrapper<typename Visitor::result_type>::type
    apply_visitor(const Visitor & visitor) {
        using result_type = typename Visitor::result_type;
        result_type result;
        static constexpr size_type index = this_type::index_of<result_type>();
        if (this_type::is_valid_index(index)) {
            result = visitor((this->template get<result_type>()));
        } else if (this->holds_alternative<result_type>() || std::is_same<result_type, this_type>::value) {
            helper_type::template apply_visitor<result_type, Visitor>(
                this->type_index_, (void *)&this->data_, &result, visitor);
        }
        return result;
    }
}; // class Variant<Types...>

template <typename... Types>
inline
Variant<Types...> operator + (const Variant<Types...> & lhs, const Variant<Types...> & rhs) {
    return lhs.add(rhs);
}

template <typename... Types>
inline
Variant<Types...> operator - (const Variant<Types...> & lhs, const Variant<Types...> & rhs) {
    return lhs.sub(rhs);
}

template <std::size_t I, typename... Types>
static bool holds_alternative(const Variant<Types...> & variant) noexcept {
    std::size_t index = variant.index();
    return ((I == index) && variant.valueless_by_exception());
}

template <typename T, typename... Types>
static bool holds_alternative(const Variant<Types...> & variant) noexcept {
    using U = typename std::remove_reference<T>::type;
    return variant.template holds_alternative<U>();
}

template <typename T, typename... Types>
T & get(Variant<Types...> & variant) {
    return variant.template get<T>();
}

template <typename T, typename... Types>
const T & get(const Variant<Types...> & variant) {
    return variant.template get<T>();
}

template <std::size_t I, typename... Types>
typename VariantAlternative<I, Types...>::type & get(Variant<Types...> & variant) {
    return variant.template get<I>();
}

template <std::size_t I, typename... Types>
const typename VariantAlternative<I, Types...>::type & get(const Variant<Types...> & variant) {
    return variant.template get<I>();
}

template <typename Arg0, typename Visitor>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(Visitor && visitor) {
    using result_type = typename function_traits<Visitor>::result_type;
    return result_type();
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(Visitor & visitor, Arg & arg) {
    using result_type = typename function_traits<Visitor>::result_type;
    using result_type_t = typename return_type_traits<result_type>::type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    result_type_t result;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
        static_assert(true, "Error: visit_impl_return(visitor, arg) invalid return type.");
    } else {
        static constexpr bool result_is_same = std::is_same<result_type_t, Arg_>::value;
        static constexpr bool arg_is_same = std::is_same<Arg0_, Arg_>::value;
        static constexpr bool arg_is_constructible = std::is_constructible<Arg0_, Arg_>::value;
        static constexpr bool result_is_same_as_arg = std::is_same<result_type_t, Arg0_>::value;

        if (!std::is_same<result_type_t, void_type>::value &&
            !std::is_same<result_type_t, MonoState>::value) {
            if (arg_is_same || arg_is_constructible) {
                result = visitor(arg);
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }

            if (result_is_same || result_is_same_as_arg) {
                arg = result;
            }
        } else {
            if (arg_is_same || arg_is_constructible) {
                visitor(arg);
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }
        }
    }

    return result;
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(const Visitor & visitor, Arg & arg) {
    using result_type = typename function_traits<Visitor>::result_type;
    using result_type_t = typename return_type_traits<result_type>::type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    result_type_t result;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
        static_assert(true, "Error: visit_impl_return(visitor, arg) invalid return type.");
    } else {
        static constexpr bool result_is_same = std::is_same<result_type_t, Arg_>::value;
        static constexpr bool arg_is_same = std::is_same<Arg0_, Arg_>::value;
        static constexpr bool arg_is_constructible = std::is_constructible<Arg0_, Arg_>::value;
        static constexpr bool result_is_same_as_arg = std::is_same<result_type_t, Arg0_>::value;

        if (!std::is_same<result_type_t, void_type>::value &&
            !std::is_same<result_type_t, MonoState>::value) {
            if (arg_is_same || arg_is_constructible) {
                result = visitor(arg);
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }

            if (result_is_same || result_is_same_as_arg) {
                arg = result;
            }
        } else {
            if (arg_is_same || arg_is_constructible) {
                visitor(arg);
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }
        }
    }

    return result;
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(Visitor & visitor, Arg && arg) {
    using result_type = typename function_traits<Visitor>::result_type;
    using result_type_t = typename return_type_traits<result_type>::type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    result_type_t result;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
        static_assert(true, "Error: visit_impl_return(visitor, arg) invalid return type.");
    } else {
        static constexpr bool result_is_same = std::is_same<result_type_t, Arg_>::value;
        static constexpr bool arg_is_same = std::is_same<Arg0_, Arg_>::value;
        static constexpr bool arg_is_constructible = std::is_constructible<Arg0_, Arg_>::value;
        static constexpr bool result_is_same_as_arg = std::is_same<result_type_t, Arg0_>::value;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg>::value;

        if (!std::is_same<result_type_t, void_type>::value &&
            !std::is_same<result_type_t, MonoState>::value) {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }

            if (result_is_same || result_is_same_as_arg) {
                arg = result;
            }
        } else {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }
        }
    }

    return result;
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(const Visitor & visitor, Arg && arg) {
    using result_type = typename function_traits<Visitor>::result_type;
    using result_type_t = typename return_type_traits<result_type>::type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    result_type_t result;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
        static_assert(true, "Error: visit_impl_return(visitor, arg) invalid return type.");
    } else {
        static constexpr bool result_is_same = std::is_same<result_type_t, Arg_>::value;
        static constexpr bool arg_is_same = std::is_same<Arg0_, Arg_>::value;
        static constexpr bool arg_is_constructible = std::is_constructible<Arg0_, Arg_>::value;
        static constexpr bool result_is_same_as_arg = std::is_same<result_type, Arg0_>::value;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg>::value;

        if (!std::is_same<result_type_t, void_type>::value &&
            !std::is_same<result_type_t, MonoState>::value) {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }

            if (result_is_same || result_is_same_as_arg) {
                arg = result;
            }
        } else {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }
        }
    }

    return result;
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(Visitor && visitor, Arg && arg) {
    using result_type = typename function_traits<Visitor>::result_type;
    using result_type_t = typename return_type_traits<result_type>::type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    result_type_t result;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
        static_assert(true, "Error: visit_impl_return(visitor, arg) invalid return type.");
    } else {
        static constexpr bool result_is_same = std::is_same<result_type_t, Arg_>::value;
        static constexpr bool arg_is_same = std::is_same<Arg0_, Arg_>::value;
        static constexpr bool arg_is_constructible = std::is_constructible<Arg0_, Arg_>::value;
        static constexpr bool result_is_same_as_arg = std::is_same<result_type, Arg0_>::value;

        static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg>::value;

        if (!std::is_same<result_type_t, void_type>::value &&
            !std::is_same<result_type_t, MonoState>::value) {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    result = std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }

            if (result_is_same || result_is_same_as_arg) {
                arg = result;
            }
        } else {
            if (arg_is_same || arg_is_constructible) {
                if (isMoveSemantics)
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
                else
                    std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
            } else {
                throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch. [visit_impl_return]");
            }
        }
    }

    return result;
}

template <typename Arg0, typename Visitor, typename Arg, typename... Args>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit_impl_return(Visitor && visitor, Arg && arg, Args &&... args) {
    static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg>::value;
    visit_impl_return<Arg0>(std::forward<Visitor>(visitor), std::forward<Arg>(arg));
    return visit_impl_return<Arg0>(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
}

template <typename Arg0, typename Visitor>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit_impl(Visitor && visitor) {
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit_impl(Visitor & visitor, Arg & arg) {
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else if (std::is_same<Arg0_, Arg_>::value || std::is_constructible<Arg0_, Arg_>::value) {
        visitor(arg);
    } else {
        throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch.");
    }
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit_impl(const Visitor & visitor, Arg & arg) {
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else if (std::is_same<Arg0_, Arg_>::value || std::is_constructible<Arg0_, Arg_>::value) {
        visitor(arg);
    } else {
        throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch.");
    }
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value
                        && std::is_lvalue_reference<Arg>::value, void>::type
visit_impl(Visitor && visitor, Arg && arg) {
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else if (std::is_same<Arg0_, Arg_>::value || std::is_constructible<Arg0_, Arg_>::value) {
        std::forward<Visitor>(visitor)(std::forward<Arg>(arg));
    } else {
        throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch.");
    }
}

template <typename Arg0, typename Visitor, typename Arg>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type, void_type>::value
                        && !std::is_lvalue_reference<Arg>::value, void>::type
visit_impl(Visitor && visitor, Arg && arg) {
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    using ArgT = typename std::remove_reference<Arg>::type;
    using Arg_ = typename std::remove_cv<ArgT>::type;

    static constexpr bool isMoveSemantics = !std::is_lvalue_reference<Arg>::value;

    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else if (std::is_same<Arg0_, Arg_>::value || std::is_constructible<Arg0_, Arg_>::value) {
        std::forward<Visitor>(visitor)(std::move(std::forward<Arg>(arg)));
    } else {
        throw BadVariantAccess("Exception: jstd::visit(visitor, arg): Type Arg is dismatch.");
    }
}

template <typename Arg0, typename Visitor, typename... Types>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit_impl(Visitor && visitor, Variant<Types...> && variant) {
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else if (std::is_same<Arg0_, Variant<Types...>>::value) {
        std::forward<Variant<Types...>>(variant).visit(std::forward<Visitor>(visitor));
    } else if (holds_alternative<Arg0T, Types...>(std::forward<Variant<Types...>>(variant))) {
        std::forward<Visitor>(visitor)(get<Arg0T>(std::forward<Variant<Types...>>(variant)));
    } else {
        throw BadVariantAccess("Exception: jstd::visit(visitor, variant): Type T is dismatch.");
    }
}

template <typename Arg0, typename Visitor, typename Arg, typename... Args>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit_impl(Visitor && visitor, Arg && arg, Args &&... args) {
    visit_impl<Arg0>(std::forward<Visitor>(visitor), std::forward<Arg>(arg));
    visit_impl<Arg0>(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
}

template <typename Visitor, typename... Args>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit(Visitor && visitor, Args &&... args) {
    using result_type = typename function_traits<Visitor>::result_type;
    using Arg0 = typename function_traits<Visitor>::arg0;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    static constexpr bool has_result_type = !std::is_same<result_type, void>::value &&
                                            !std::is_same<result_type, void_type>::value;
    result_type result;
    if (std::is_same<Arg0_, void>::value) {
        // No return
    } else if (std::is_same<Arg0_, void_type>::value ||
               std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else {
        if (std::is_same<result_type, void_type>::value) {
            visit_impl_return<Arg0>(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
        } else {
            result = visit_impl_return<Arg0>(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
        }
    }
    return result;
}

template <typename Visitor, typename... Args>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit(Visitor && visitor, Args &&... args) {
    using Arg0 = typename function_traits<Visitor>::template arguments<0>::type;
    using result_type = typename function_traits<Visitor>::result_type;
    using Arg0T = typename std::remove_reference<Arg0>::type;
    using Arg0_ = typename std::remove_cv<Arg0T>::type;
    static constexpr bool has_result_type = !std::is_same<result_type, void>::value &&
                                            !std::is_same<result_type, void_type>::value;
    if (std::is_same<Arg0_, void>::value ||
        std::is_same<Arg0_, void_type>::value ||
        std::is_same<Arg0_, MonoState>::value) {
        // No return
    } else {
        visit_impl<Arg0>(std::forward<Visitor>(visitor), std::forward<Args>(args)...);
    }
}

template <typename Visitor>
typename std::enable_if<!std::is_same<typename function_traits<Visitor>::result_type, void_type>::value,
                        typename function_traits<Visitor>::result_type>::type
visit(Visitor && visitor) {
    return std::forward<Visitor>(visitor)();
}

template <typename Visitor>
typename std::enable_if<std::is_same<typename function_traits<Visitor>::result_type,
                        void_type>::value, void>::type
visit(Visitor && visitor) {
    std::forward<Visitor>(visitor)();
}

} // namespace jstd

template <>
struct std::hash<jstd::MonoState> {
    using argument_type = jstd::MonoState;
    using result_type = std::size_t;

    inline result_type operator () (const argument_type &) const noexcept {
        // return a fundamentally attractive random value.
        return 66740831;
    }
};

#endif // JSTD_VARIANT_H

/***********************************************************************
  CmdLine.h
***********************************************************************/

#ifndef APP_CMD_LINE_H
#define APP_CMD_LINE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#if defined(_WIN32) || defined(WIN32) || defined(OS_WINDOWS) || defined(_WINDOWS_)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif // WIN32_LEAN_AND_MEAN
#endif // _WIN32

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#if defined(_MSC_VER)
#include <tchar.h>
#endif

#include <string>
#include <cstring>
#include <vector>
#include <unordered_map>


#if defined(_MSC_VER)
#ifndef __attribute__
#define __attribute__(x)
#endif
#endif // _MSC_VER

// Text is Unicode on Windows or wchar_t on Linux ?
#define USE_WIDE_CHAR_TEXT  0

#define _Ansi(x)        x
#define _LText(x)       L ## x

#ifndef _Text
  #if USE_WIDE_CHAR_TEXT
    #define _Text(x)    _LText(x)
  #else
    #define _Text(x)    _Ansi(x)
  #endif
#endif

#ifndef UNUSED_VAR
#define UNUSED_VAR(var)  ((void)var)
#endif

namespace app {

FILE * const LOG_FILE = stderr;

struct Error {
    enum {
        ErrorFirst = -20000,

        // Default Errors
        CmdLine_UnknownArgument,
        CmdLine_UnrecognizedArgument,
        CmdLine_EmptyArgumentName,
        CmdLine_ShortPrefixArgumentNameTooLong,
        CmdLine_LongPrefixArgumentNameTooShort,
        CmdLine_CouldNotParseArgumentValue,
        CmdLine_IllegalFormat,
        ExitProcess,

        // User errors
        UserErrorStart = -10000,

        NoError = 0,
    };

    static bool isSuccess(int error_id) {
        return (error_id == NoError);
    }

    static bool isError(int error_id) {
        return (error_id < NoError);
    }
};

template <typename CharT = char>
static inline
bool is_empty_or_null(const std::basic_string<CharT> & str)
{
    if (str.empty()) {
        return true;
    } else {
        const CharT * data = str.c_str();
        if (data != nullptr) {
            // Trim left
            std::size_t ltrim = str.find_first_not_of(CharT(' '));
            if (ltrim == std::basic_string<CharT>::npos)
                ltrim = str.size();
            // Trim right
            std::size_t rtrim = str.find_last_not_of(CharT(' '));
            if (rtrim == std::basic_string<CharT>::npos)
                rtrim = 0;
            else
                ++rtrim;

            return (ltrim >= rtrim);
        } else {
            return true;
        }
    }
}

template <typename CharT = char>
static inline
std::size_t find_first_not_of(const std::basic_string<CharT> & str, CharT token,
                              std::size_t first, std::size_t last)
{
    std::size_t cur = first;
    while (cur < last) {
        if (str[cur] == token)
            ++cur;
        else
            return cur;
    }
    return std::basic_string<CharT>::npos;
}

template <typename CharT = char>
static inline
std::size_t find_last_not_of(const std::basic_string<CharT> & str, CharT token,
                             std::size_t first, std::size_t last)
{
    std::size_t cur = --last;
    while (cur >= first) {
        if (str[cur] == token)
            --cur;
        else
            return (cur + 1);
    }
    return std::basic_string<CharT>::npos;
}

template <typename CharT = char>
static inline
void string_trim_left(const std::basic_string<CharT> & str,
                      std::size_t & first, std::size_t last)
{
    // Trim left
    std::size_t ltrim = find_first_not_of<CharT>(str, CharT(' '), first, last);
    if (ltrim == std::basic_string<CharT>::npos)
        ltrim = last;

    first = ltrim;
}

template <typename CharT = char>
static inline
void string_trim_right(const std::basic_string<CharT> & str,
                       std::size_t first, std::size_t & last)
{
    // Trim right
    std::size_t rtrim = find_last_not_of<CharT>(str, CharT(' '), first, last);
    if (rtrim == std::basic_string<CharT>::npos)
        rtrim = first;

    last = rtrim;
}

template <typename CharT = char>
static inline
void string_trim(const std::basic_string<CharT> & str,
                 std::size_t & first, std::size_t & last)
{
    // Trim left
    std::size_t ltrim = find_first_not_of<CharT>(str, CharT(' '), first, last);
    if (ltrim == std::basic_string<CharT>::npos)
        ltrim = last;

    // Trim right
    std::size_t rtrim = find_last_not_of<CharT>(str, CharT(' '), ltrim, last);
    if (rtrim == std::basic_string<CharT>::npos)
        rtrim = ltrim;

    first = ltrim;
    last = rtrim;
}

template <typename CharT = char>
static inline
std::size_t string_copy(std::basic_string<CharT> & dest,
                        const std::basic_string<CharT> & src,
                        std::size_t first, std::size_t last)
{
    for (std::size_t i = first; i < last; i++) {
        dest.push_back(src[i]);
    }
    return (last > first) ? (last - first) : 0;
}

template <typename CharT = char>
static inline
std::size_t string_copy_n(std::basic_string<CharT> & dest,
                          const std::basic_string<CharT> & src,
                          std::size_t offset, std::size_t count)
{
    std::size_t last = offset + count;
    for (std::size_t i = offset; i < last; i++) {
        dest.push_back(src[i]);
    }
    return count;
}

struct Slice {
    std::size_t first;
    std::size_t last;

    Slice() noexcept : first(0), last(0) {
    }

    Slice(std::size_t _first, std::size_t _last) noexcept
        : first(_first), last(_last) {
    }

    Slice(const Slice & src) noexcept
        : first(src.first), last(src.last) {
    }

    std::size_t size() const  {
        return (last > first) ? (last - first - 1) : std::size_t(0);
    }

    bool is_last(std::size_t i) const {
        return ((last > 0) && (i >= (last - 1)));
    }
};

struct SliceEx {
    std::size_t first;
    std::size_t last;
    std::size_t token;
    std::size_t count;

    SliceEx() noexcept : first(0), last(0), token(0), count(0) {
    }

    SliceEx(std::size_t _first, std::size_t _last) noexcept
        : first(_first), last(_last), token(0), count(0) {
    }

    SliceEx(const SliceEx & src) noexcept
        : first(src.first), last(src.last),
          token(src.token), count(src.count) {
    }

    std::size_t size() const {
        return (last > first) ? (last - first - 1) : std::size_t(0);
    }

    bool is_last(std::size_t i) const {
        return ((last > 0) && (i >= (last - 1)));
    }
};

template <typename CharT = char>
static inline
void split_string_by_token(const std::basic_string<CharT> & text, CharT token,
                           std::vector<Slice> & word_list)
{
    word_list.clear();

    std::size_t last_pos = 0;
    do {
        std::size_t token_pos = text.find_first_of(token, last_pos);
        if (token_pos == std::basic_string<CharT>::npos) {
            token_pos = text.size();
        }

        std::size_t ltrim = last_pos;
        std::size_t rtrim = token_pos;

        // Trim left and right space chars
        string_trim<CharT>(text, ltrim, rtrim);

        if (ltrim < rtrim) {
            Slice word(ltrim, rtrim);
            std::size_t len = rtrim - ltrim;
            assert(len > 0);
            word_list.push_back(word);
        }

        if (token_pos < text.size())
            last_pos = token_pos + 1;
        else
            break;
    } while (1);
}

template <typename CharT = char>
static inline
void split_string_by_token(const std::basic_string<CharT> & text, CharT token,
                           std::vector<std::basic_string<CharT>> & word_list)
{
    word_list.clear();

    std::size_t last_pos = 0;
    do {
        std::size_t token_pos = text.find_first_of(token, last_pos);
        if (token_pos == std::basic_string<CharT>::npos) {
            token_pos = text.size();
        }

        std::size_t ltrim = last_pos;
        std::size_t rtrim = token_pos;

        // Trim left and right space chars
        string_trim<CharT>(text, ltrim, rtrim);

        if (ltrim < rtrim) {
            std::basic_string<CharT> word;
            std::size_t len = string_copy(word, text, ltrim, rtrim);
            assert(len > 0);
            word_list.push_back(word);
        }

        if (token_pos < text.size())
            last_pos = token_pos + 1;
        else
            break;
    } while (1);
}

template <typename CharT = char>
static inline
void split_string_by_token(const std::basic_string<CharT> & text,
                           const std::basic_string<CharT> & tokens,
                           std::vector<std::basic_string<CharT>> & word_list)
{
    word_list.clear();

    std::size_t last_pos = 0;
    do {
        std::size_t token_pos = text.find_first_of(tokens, last_pos);
        if (token_pos == std::basic_string<CharT>::npos) {
            token_pos = text.size();
        }

        std::size_t ltrim = last_pos;
        std::size_t rtrim = token_pos;

        // Trim left and right space chars
        string_trim<CharT>(text, ltrim, rtrim);

        if (ltrim < rtrim) {
            std::basic_string<CharT> word;
            std::size_t len = string_copy(word, text, ltrim, rtrim);
            assert(len > 0);
            word_list.push_back(word);
        }

        if (token_pos < text.size())
            last_pos = token_pos + 1;
        else
            break;
    } while (1);
}

///////////////////////////////////////////////////////////////////////////////////////

typedef jstd::Variant<unsigned long long, long long,
                      bool, char, short, int, long,
                      unsigned char, unsigned short, unsigned int, unsigned long,
                      signed char, wchar_t, char16_t, char32_t,
                      float, double, long double,
                      std::string, std::wstring,
                      void *, const void *,
                      char *, const char *,
                      short *, const short *,
                      wchar_t *, const wchar_t *,
                      char16_t *, const char16_t *,
                      char32_t *, const char32_t *
        > Variant;

///////////////////////////////////////////////////////////////////////////////////////

template <typename CharT>
struct Converter {
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type> string_type;

    template <typename... Types>
    static inline
    bool try_convert(jstd::Variant<Types...> & dest,
                     const string_type & value,
                     const char_type * value_start) {
        bool convertible = false;
        std::size_t index = dest.index();
        std::type_index type_index = dest.type_index();
        try {
            if (0) {
                // Do nothing !!
            } else if (type_index == typeid(char_type *)) {
                dest = (char_type *)value_start;
                convertible = true;
            } else if (type_index == typeid(const char_type *)) {
                dest = (const char_type *)value_start;
                convertible = true;
            } else if (type_index == typeid(void *)) {
                dest = (void *)value_start;
                convertible = true;
            } else if (type_index == typeid(const void *)) {
                dest = (const void *)value_start;
                convertible = true;
            } else if (type_index == typeid(bool)) {
                dest = (bool)(std::stoi(value) != 0);
                convertible = true;
            } else if (type_index == typeid(char)) {
                dest = (char)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(signed char)) {
                dest = (signed char)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(unsigned char)) {
                dest = (unsigned char)std::stoul(value);
                convertible = true;
            } else if (type_index == typeid(short)) {
                dest = (short)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(signed short)) {
                dest = (signed short)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(unsigned short)) {
                dest = (unsigned short)std::stoul(value);
                convertible = true;
            } else if (type_index == typeid(int)) {
                dest = (int)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(int32_t)) {
                dest = (int32_t)std::stoi(value);
                convertible = true;
            } else if (type_index == typeid(long)) {
                dest = (long)std::stol(value);
                convertible = true;
            } else if (type_index == typeid(long long)) {
                dest = (long long)std::stoll(value);
                convertible = true;
            } else if (type_index == typeid(int64_t)) {
                dest = (int64_t)std::stoll(value);
                convertible = true;
            } else if (type_index == typeid(unsigned int)) {
                dest = (unsigned int)std::stoul(value);
                convertible = true;
            } else if (type_index == typeid(uint32_t)) {
                dest = (uint32_t)std::stoul(value);
                convertible = true;
            } else if (type_index == typeid(unsigned long)) {
                dest = (unsigned long)std::stoul(value);
                convertible = true;
            } else if (type_index == typeid(unsigned long long)) {
                dest = (unsigned long long)std::stoull(value);
                convertible = true;
            } else if (type_index == typeid(uint64_t)) {
                dest = (uint64_t)std::stoull(value);
                convertible = true;
            } else if (type_index == typeid(size_t)) {
                dest = (size_t)std::stoull(value);
                convertible = true;
            } else if (type_index == typeid(intptr_t)) {
                dest = (intptr_t)std::stoll(value);
                convertible = true;
            } else if (type_index == typeid(uintptr_t)) {
                dest = (uintptr_t)std::stoull(value);
                convertible = true;
            } else if (type_index == typeid(ptrdiff_t)) {
                dest = (ptrdiff_t)std::stoll(value);
                convertible = true;
            } else if (type_index == typeid(float)) {
                dest = (float)std::stof(value);
                convertible = true;
            } else if (type_index == typeid(double)) {
                dest = (double)std::stod(value);
                convertible = true;
            } else if (type_index == typeid(long double)) {
                dest = (long double)std::stold(value);
                convertible = true;
            } else if (type_index == typeid(string_type)) {
                dest = value;
                convertible = true;
            }
        } catch(const std::invalid_argument & ex) {
            std::cout << "std::invalid_argument::what(): " << ex.what() << '\n';
        } catch(const std::out_of_range & ex) {
            std::cout << "std::out_of_range::what(): " << ex.what() << '\n';
        } catch (const jstd::BadVariantAccess & ex) {
            std::cout << "jstd::BadVariantAccess::what(): " << ex.what() << '\n';
        }
        return convertible;
    }

    template <typename... Types>
    static inline
    bool try_to_string(const jstd::Variant<Types...> & src,
                       string_type & dest) {
        bool convertible = false;
        std::size_t index = src.index();
        std::type_index type_index = src.type();
        try {
            if (0) {
                // Do nothing !!
            } else if (type_index == typeid(char_type *)) {
                dest = string_type(src.template get<char_type *>());
                convertible = true;
            } else if (type_index == typeid(const char_type *)) {
                dest = string_type(src.template get<const char_type *>());
                convertible = true;
            } else if (type_index == typeid(void *)) {
                dest = string_type((char_type *)src.template get<void *>());
                convertible = true;
            } else if (type_index == typeid(const void *)) {
                dest = string_type((const char_type *)src.template get<const void *>());
                convertible = true;
            } else if (type_index == typeid(bool)) {
                dest = std::to_string((uint32_t)src.template get<bool>());
                convertible = true;
            } else if (type_index == typeid(char)) {
                dest = std::to_string((int32_t)src.template get<char>());
                convertible = true;
            } else if (type_index == typeid(signed char)) {
                dest = std::to_string((int32_t)src.template get<signed char>());
                convertible = true;
            } else if (type_index == typeid(unsigned char)) {
                dest = std::to_string((uint32_t)src.template get<unsigned char>());
                convertible = true;
            } else if (type_index == typeid(short)) {
                dest = std::to_string((int32_t)src.template get<short>());
                convertible = true;
            } else if (type_index == typeid(signed short)) {
                dest = std::to_string((int32_t)src.template get<signed short>());
                convertible = true;
            } else if (type_index == typeid(unsigned short)) {
                dest = std::to_string((uint32_t)src.template get<unsigned short>());
                convertible = true;
            } else if (type_index == typeid(int)) {
                dest = std::to_string(src.template get<int>());
                convertible = true;
            } else if (type_index == typeid(int32_t)) {
                dest = std::to_string(src.template get<int32_t>());
                convertible = true;
            } else if (type_index == typeid(long)) {
                dest = std::to_string(src.template get<long>());
                convertible = true;
            } else if (type_index == typeid(long long)) {
                dest = std::to_string(src.template get<long long>());
                convertible = true;
            } else if (type_index == typeid(int64_t)) {
                dest = std::to_string(src.template get<int64_t>());
                convertible = true;
            } else if (type_index == typeid(unsigned int)) {
                dest = std::to_string(src.template get<unsigned int>());
                convertible = true;
            } else if (type_index == typeid(uint32_t)) {
                dest = std::to_string(src.template get<uint32_t>());
                convertible = true;
            } else if (type_index == typeid(unsigned long)) {
                dest = std::to_string(src.template get<unsigned long>());
                convertible = true;
            } else if (type_index == typeid(unsigned long long)) {
                dest = std::to_string(src.template get<unsigned long long>());
                convertible = true;
            } else if (type_index == typeid(uint64_t)) {
                dest = std::to_string(src.template get<uint64_t>());
                convertible = true;
            } else if (type_index == typeid(size_t)) {
                dest = std::to_string(src.template get<size_t>());
                convertible = true;
            } else if (type_index == typeid(intptr_t)) {
                dest = std::to_string(src.template get<intptr_t>());
                convertible = true;
            } else if (type_index == typeid(uintptr_t)) {
                dest = std::to_string(src.template get<uintptr_t>());
                convertible = true;
            } else if (type_index == typeid(ptrdiff_t)) {
                dest = std::to_string(src.template get<ptrdiff_t>());
                convertible = true;
            } else if (type_index == typeid(float)) {
                dest = std::to_string(src.template get<float>());
                convertible = true;
            } else if (type_index == typeid(double)) {
                dest = std::to_string(src.template get<double>());
                convertible = true;
            } else if (type_index == typeid(long double)) {
                dest = std::to_string(src.template get<long double>());
                convertible = true;
            } else if (type_index == typeid(string_type)) {
                dest = src.template get<string_type>();
                convertible = true;
            }
        } catch(const std::invalid_argument & ex) {
            std::cout << "std::invalid_argument::what(): " << ex.what() << '\n';
        } catch(const std::out_of_range & ex) {
            std::cout << "std::out_of_range::what(): " << ex.what() << '\n';
        } catch (const jstd::BadVariantAccess & ex) {
            std::cout << "jstd::BadVariantAccess::what(): " << ex.what() << '\n';
        }
        return convertible;
    }
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename VariantT, typename CharT = char>
struct StringConverter : public ::jstd::static_visitor<VariantT> {
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type> string_type;
    typedef VariantT                     result_type;

    const string_type & value;
    const char_type *   value_start;

    StringConverter(const string_type & arg_value,
                    const char_type * arg_start) noexcept
        : value(arg_value), value_start(arg_start) {
    }

    result_type operator () (char_type * p) {
        UNUSED_VAR(p);
        result_type variant((char_type *)value_start);
        return variant;
    }

    result_type operator () (const char_type * p) {
        UNUSED_VAR(p);
        result_type variant((const char_type *)value_start);
        return variant;
    }

    result_type operator () (char_type * const p) const {
        UNUSED_VAR(p);
        result_type variant((char_type * const)value_start);
        return variant;
    }

    result_type operator () (const char_type * const p) const {
        UNUSED_VAR(p);
        result_type variant((const char_type * const)value_start);
        return variant;
    }

    result_type operator () (void * p) const {
        UNUSED_VAR(p);
        result_type variant((void *)value_start);
        return variant;
    }

    result_type operator () (const void * p) const {
        UNUSED_VAR(p);
        result_type variant((const void *)value_start);
        return variant;
    }

    result_type operator () (bool i) const {
        UNUSED_VAR(i);
        result_type variant((bool)(std::stoi(value) != 0));
        return variant;
    }

    result_type operator () (char i) const {
        UNUSED_VAR(i);
        result_type variant((char)std::stoi(value));
        return variant;
    }

    result_type operator () (signed char i) const {
        UNUSED_VAR(i);
        result_type variant((signed char)std::stoi(value));
        return variant;
    }

    result_type operator () (unsigned char i) const {
        UNUSED_VAR(i);
        result_type variant((unsigned char)std::stoul(value));
        return variant;
    }

    result_type operator () (short i) const {
        UNUSED_VAR(i);
        result_type variant((short)std::stoi(value));
        return variant;
    }

    result_type operator () (unsigned short i) const {
        UNUSED_VAR(i);
        result_type variant((unsigned short)std::stoul(value));
        return variant;
    }

    result_type operator () (int i) const {
        UNUSED_VAR(i);
        result_type variant((int)std::stoi(value));
        return variant;
    }

    result_type operator () (long i) const {
        UNUSED_VAR(i);
        result_type variant((long)std::stol(value));
        return variant;
    }

    result_type operator () (long long i) const {
        UNUSED_VAR(i);
        result_type variant((long long)std::stoll(value));
        return variant;
    }

    result_type operator () (unsigned int i) const {
        UNUSED_VAR(i);
        result_type variant((unsigned int)std::stoul(value));
        return variant;
    }

    result_type operator () (unsigned long i) const {
        UNUSED_VAR(i);
        result_type variant((unsigned long)std::stoul(value));
        return variant;
    }

    result_type operator () (unsigned long long i) const {
        UNUSED_VAR(i);
        result_type variant((unsigned long long)std::stoull(value));
        return variant;
    }

    result_type operator () (float f) const {
        UNUSED_VAR(f);
        result_type variant((float)std::stof(value));
        return variant;
    }

    result_type operator () (double d) const {
        UNUSED_VAR(d);
        result_type variant((double)std::stod(value));
        return variant;
    }

    result_type operator () (long double d) const {
        UNUSED_VAR(d);
        result_type variant((long double)std::stold(value));
        return variant;
    }

    result_type operator () (const string_type & str) const {
        UNUSED_VAR(str);
        result_type variant(value);
        return variant;
    }

    result_type operator () (const result_type & var) const {
        result_type variant(var);
        return variant;
    }
};

template <typename CharT = char>
struct StringFormatter : public ::jstd::static_visitor< std::basic_string<CharT> > {
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type> string_type;
    typedef string_type                  result_type;
    typedef Variant                      variant_t;

    result_type operator () (char_type * src, const variant_t & var) const {
        return result_type();
    }
};

///////////////////////////////////////////////////////////////////////////////////////

template <typename CharT = char>
struct BasicConfig {
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type> string_type;

    BasicConfig() {
    }

    bool assert_check(bool condition, const char * format, ...)
        __attribute__((format(printf, 3, 4))) {
        if (!condition) {
            va_list args;
            va_start(args, format);
            vfprintf(LOG_FILE, format, args);
            va_end(args);
        }
        return condition;
    }

#if defined(_MSC_VER)
    bool assert_check(bool condition, const wchar_t * format, ...)
        __attribute__((format(printf, 3, 4))) {
        if (!condition) {
            va_list args;
            va_start(args, format);
            vfwprintf(LOG_FILE, format, args);
            va_end(args);
        }
        return condition;
    }
#endif

    virtual int validate() {
        return Error::NoError;
    }
};

///////////////////////////////////////////////////////////////////////////////////////

struct OptType {
    enum {
        Unknown,
        Text,
        Void,
        String,
    };
};

template <typename CharT = char>
struct PrintStyle {
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef std::basic_string<char_type>                    string_type;

    typedef std::size_t size_type;

    bool compact_style;
    bool auto_fit;
    size_type tab_size;
    size_type ident_spaces;
    size_type min_padding;
    size_type max_start_pos;
    size_type max_column;

    string_type separator;

    PrintStyle() : compact_style(true), auto_fit(false),
                   tab_size(4), ident_spaces(2), min_padding(1),
                   max_start_pos(35), max_column(80) {
        this->separator.push_back(char_type(':'));
    }
};

template <typename CharT = char>
class VirtualTextArea {
    typedef VirtualTextArea<CharT>                          this_type;
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type>                    string_type;

    typedef std::size_t size_type;

    static const size_type kMaxReservedSize = 4096;

public:
    VirtualTextArea(const PrintStyle<char_type> & print_style)
        : print_style_(print_style), lines_(0) {
    }

protected:
    const PrintStyle<char_type> & print_style_;
    string_type text_buf_;
    size_type lines_;

public:
    size_type size() const {
        return text_buf_.size();
    }

    size_type lines() const {
        return lines_;
    }

    size_type acutal_lines() const {
        return (text_buf_.size() / (print_style_.max_column + 1));
    }

    size_type capacity_lines() const {
        return (text_buf_.capacity() / (print_style_.max_column + 1));
    }

    size_type virtual_pos(size_type rows, size_type cols) const {
        return (rows * (print_style_.max_column + 1) + cols);
    }

     PrintStyle<char_type> & print_style() {
        return const_cast<PrintStyle<char_type> &>(this->print_style_);
    }

    const PrintStyle<char_type> & print_style() const {
        return this->print_style_;
    }

    void clear() {
        text_buf_.clear();
        lines_ = 0;
    }

    void reset(char_type ch = char_type(' ')) {
        if (text_buf_.size() <= kMaxReservedSize) {
            std::fill_n(&text_buf_[0], text_buf_.size(), ch);
        } else {
            text_buf_.resize(kMaxReservedSize, ch);
        }
        lines_ = 0;
    }

    void reserve_lines(size_type lines) {
        text_buf_.reserve((print_style_.max_column + 1) * lines);
    }

    void resize_lines(size_type lines, char_type ch = char_type(' ')) {
        text_buf_.resize((print_style_.max_column + 1) * lines, ch);
    }

    void prepare_add_lines(size_type lines) {
        size_type n_acutal_lines = this->acutal_lines();
        size_type new_lines = this->lines_ + lines;
        if (new_lines > n_acutal_lines) {
            this->resize_lines(new_lines * 3 / 2 + 1);
        }
    }

    void append_text(size_type offset, const string_type & text,
                     const std::vector<Slice> & line_list,
                     bool update_lines = true) {
        prepare_add_lines(line_list.size());

        size_type lines = this->lines_;
        for (auto const & line : line_list) {
            size_type pos = virtual_pos(lines, offset);
            for (size_type i = line.first; i < line.last; i++) {
                text_buf_[pos++] = text[i];
            }
            lines++;
        }

        if (update_lines) {
            this->lines_ = lines;
        }
    }

    void append_text(size_type offset_x, size_type offset_y,
                     size_type total_lines,
                     const string_type & text,
                     const std::vector<Slice> & line_list,
                     bool update_lines = true) {
        assert(total_lines >= line_list.size());
        prepare_add_lines(total_lines);

        size_type lines = this->lines_ + offset_y;
        for (auto const & line : line_list) {
            size_type pos = virtual_pos(lines, offset_x);
            for (size_type i = line.first; i < line.last; i++) {
                text_buf_[pos++] = text[i];
            }
            lines++;
        }

        if (update_lines) {
            this->lines_ = lines;
        }
    }

    void append_text(size_type offset,
                     const std::vector<string_type> & line_list,
                     bool update_lines = true) {
        prepare_add_lines(line_list.size());

        size_type lines = this->lines_;
        for (auto const & line : line_list) {
            size_type pos = virtual_pos(lines, offset);
            for (size_type i = 0; i < line.size(); i++) {
                text_buf_[pos++] = line[i];
            }
            lines++;
        }

        if (update_lines) {
            this->lines_ = lines;
        }
    }

    void append_text(size_type offset_x, size_type offset_y,
                     size_type total_lines,
                     const std::vector<string_type> & line_list,
                     bool update_lines = true) {
        assert(total_lines >= line_list.size());
        prepare_add_lines(total_lines);

        size_type lines = this->lines_ + offset_y;
        for (auto const & line : line_list) {
            size_type pos = virtual_pos(lines, offset_x);
            for (size_type i = 0; i < line.size(); i++) {
                text_buf_[pos++] = line[i];
            }
            lines++;
        }

        if (update_lines) {
            this->lines_ = lines;
        }
    }

    void append_new_line(size_type n = 1) {
        if (n > 0) {
            prepare_add_lines(n);

            for (size_type i = 0; i < n; i++) {
                size_type pos = virtual_pos(this->lines_, 0);
                text_buf_[pos] = char_type('\n');
                this->lines_++;
            }
        }
    }

    size_type prepare_display_text(const string_type & text,
                                   string_type & display_text,
                                   std::vector<string_type> & line_list,
                                   size_type max_column,
                                   bool lineCrLf = true,
                                   bool endCrLf = true) const {
        std::vector<Slice> word_list;
        split_string_by_token(text, char_type(' '), word_list);

        line_list.clear();

        string_type line;
        size_type column = 0;
        size_type last_column = 0;
        bool is_end;
        for (size_type i = 0; i < word_list.size(); i++) {
            Slice sword = word_list[i];
            string_type word;
            do {
                bool need_wrap = false;
                bool new_line = false;
                is_end = false;
                while (sword.first < sword.last) {
                    char_type ch = text[sword.first];
                    if (ch != char_type('\t')) {
                        if (ch != char_type('\n')) {
                            if (ch >= char_type(' ')) {
                                word.push_back(ch);
                            } else if (ch == char_type('\0')) {
                                is_end = true;
                                break;
                            } else {
                                // Skip the another control chars: /b /v /f /a /r
                            }
                        } else {
                            need_wrap = true;
                            break;
                        }
                    } else {
                        for (size_type i = 0; i < print_style_.tab_size; i++) {
                            word.push_back(char_type(' '));
                        }
                    }
                    sword.first++;
                }

                if ((column + word.size()) <= max_column) {
                    size_type pre_column = column + word.size();
                    if (pre_column < max_column) {
                        if (i < (word_list.size() - 1)) {
                            Slice word_next = word_list[i + 1];
                            assert(word_next.first > sword.last);
                            size_type num_space = word_next.first - sword.last;
                            assert(num_space > 0);
                            if ((pre_column + num_space) >= max_column) {
                                // If after add the space chars, it's exceed the max column,
                                // push the '\n' directly.
                                if (lineCrLf) {
                                    word.push_back(char_type('\n'));
                                }
                                new_line = true;
                            } else {
                                if (!need_wrap) {
                                    for (size_type i = 0; i < num_space; i++) {
                                        word.push_back(char_type(' '));
                                    }
                                    pre_column += num_space;
                                } else {
                                    column += word.size();
                                    if (lineCrLf) {
                                        word.push_back(char_type('\n'));
                                    }

                                    line += word;
                                    line_list.push_back(line);
                                    line.clear();

                                    last_column = pre_column;
                                    pre_column = 0;

                                    word.clear();
                                    sword.first++;
                                    continue;
                                }
                            }
                        } else {
                            if (need_wrap) {
                                if (lineCrLf) {
                                    word.push_back(char_type('\n'));
                                }

                                line += word;
                                line_list.push_back(line);
                                line.clear();

                                last_column = pre_column;
                                pre_column = 0;

                                word.clear();
                            }

                            if (endCrLf) {
                                word.push_back(char_type('\n'));
                            }
                            is_end = true;
                        }
                    } else {
                        if (lineCrLf) {
                            word.push_back(char_type('\n'));
                        }
                        new_line = true;
                    }

                    line += word;
                    column = pre_column;

                    if (new_line || need_wrap || is_end) {
                        line_list.push_back(line);
                        line.clear();

                        last_column = column;
                        column = 0;

                        if (need_wrap) {
                            word.clear();
                        }
                    }
                } else {
                    if (lineCrLf) {
                        line.push_back(char_type('\n'));
                    }
                    line_list.push_back(line);
                    line.clear();

                    last_column = column;
                    column = word.size();

                    line = word;

                    if (need_wrap) {
                        line.push_back(char_type('\n'));
                        line_list.push_back(line);
                        line.clear();

                        last_column = column;
                        column = 0;

                        sword.first++;
                    }

                    bool is_last = ((i >= (word_list.size() - 1)) && (sword.first >= sword.last));
                    if (is_last || is_end) {
                        if (endCrLf) {
                            line.push_back(char_type('\n'));
                        }
                        line_list.push_back(line);
                        line.clear();

                        last_column = column;
                        column = 0;

                        is_end = true;
                    } else if (need_wrap) {
                        word.clear();
                    }
                }

                if ((sword.first >= sword.last) || is_end) {
                    break;
                }
            } while (1);

            if (is_end)
                break;
        }

        display_text.clear();
        for (size_type i = 0; i < line_list.size(); i++) {
            display_text += line_list[i];
        }

        return last_column;
    }

    string_type output_real() {
        string_type real_text;
        for (size_type l = 0; l < this->lines(); l++) {
            size_type first_pos = virtual_pos(l, 0);
            size_type last_pos = virtual_pos(l, print_style_.max_column);
            do {
                char_type ch = text_buf_[last_pos];
                if (ch == char_type(' ')) {
                    if (last_pos == first_pos) {
                        // It's a empty line.
                        break;
                    }
                    last_pos--;
                } else {
                    if (first_pos <= last_pos) {
                        for (size_type i = first_pos; i <= last_pos; i++) {
                            real_text.push_back(text_buf_[i]);
                        }
                        if (ch != char_type('\n')) {
                            real_text.push_back(char_type('\n'));
                        }
                    } else {
                        // It's a empty line.
                        //real_text.push_back(char_type('\n'));
                    }
                    break;
                }
            } while (first_pos <= last_pos);
        }
        return real_text;
    }
};

template <typename CharT = char>
class BasicCmdLine {
public:
    typedef BasicCmdLine<CharT>                             this_type;
    typedef typename ::jstd::char_traits<CharT>::NoSigned   char_type;
    typedef typename ::jstd::char_traits<CharT>::Signed     schar_type;
    typedef typename ::jstd::char_traits<CharT>::Unsigned   uchar_type;

    typedef std::basic_string<char_type>                    string_type;

    typedef std::size_t size_type;
    typedef Variant     variant_t;

#if defined(_MSC_VER)
    static const char_type kPathSeparator = char_type('\\');
#else
    static const char_type kPathSeparator = char_type('/');
#endif

    union VariableState {
        struct {
            std::uint32_t   order;
            std::uint32_t   required   : 1;
            std::uint32_t   is_default : 1;
            std::uint32_t   visited    : 1;
            std::uint32_t   assigned   : 1;
            std::uint32_t   unused     : 28;
        };
        uint64_t value;

        VariableState() : value(0) {
        }
    };

    struct Variable {
        VariableState state;
        string_type   name;
        variant_t     value;
    };

    struct Option {
        std::uint32_t   type;
        std::uint32_t   desc_id;
        string_type     names;
        string_type     display_text;
        string_type     desc;
        Variable        variable;

        static const size_type NotFound       = (size_type)-1;
        static const std::uint32_t NotFound32 = (std::uint32_t)-1;
        static const std::uint16_t NotFound16 = (std::uint16_t)-1;

        static const size_type Unknown       = (size_type)-1;
        static const std::uint32_t Unknown32 = (std::uint32_t)-1;

        Option(std::uint32_t _type = OptType::Unknown)
            : type(_type), desc_id(Unknown32) {
        }
    };

    class OptionDesc {
    public:
        string_type title;

        std::vector<Option>                        option_list;
        std::unordered_map<string_type, size_type> option_map;

        OptionDesc() {
        }

        OptionDesc(const string_type & _title) : title(_title) {
        }

    private:
        size_type parseOptionName(const string_type & names,
                                  std::vector<string_type> & name_list,
                                  std::vector<string_type> & text_list) {
            std::vector<string_type> token_list;
            string_type tokens = _Text(", ");
            split_string_by_token(names, tokens, token_list);
            size_type nums_token = token_list.size();
            if (nums_token > 0) {
                name_list.clear();
                text_list.clear();
                for (auto iter = token_list.begin(); iter != token_list.end(); ++iter) {
                    const string_type & token = *iter;
                    string_type name;
                    size_type pos = token.find(_Text("--"));
                    if (pos == 0) {
                        for (size_type i = pos + 2; i < token.size(); i++) {
                            name.push_back(token[i]);
                        }
                        if (!is_empty_or_null(name)) {
                            name_list.push_back(name);
                        }
                    } else {
                        pos = token.find(char_type('-'));
                        if (pos == 0) {
                            for (size_type i = pos + 1; i < token.size(); i++) {
                                name.push_back(token[i]);
                            }
                            if (!is_empty_or_null(name)) {
                                name_list.push_back(name);
                            }
                        } else {
                            assert(!is_empty_or_null(token));
                            text_list.push_back(token);
                        }
                    }
                }
            }
            return name_list.size();
        }

        // Accept format: --name=abc, or -n=10, or -n 10
        int addOptionImpl(std::uint32_t type, const string_type & names,
                          const string_type & desc,
                          const variant_t & value,
                          bool is_default) {
            int err_code = Error::NoError;

            Option option(type);
            option.names = names;
            option.display_text = names;
            option.desc = desc;
            option.variable.state.is_default = is_default;
            option.variable.value = value;

            std::vector<string_type> name_list;
            std::vector<string_type> text_list;
            size_type nums_name = this->parseOptionName(names, name_list, text_list);
            if (nums_name > 0) {
                // Sort all the option names asc
                for (size_type i = 0; i < (name_list.size() - 1); i++) {
                    for (size_type j = i + 1; j < name_list.size(); j++) {
                        if (name_list[i].size() > name_list[j].size()) {
                            std::swap(name_list[i], name_list[j]);
                        } else if (name_list[i].size() == name_list[j].size()) {
                            if (name_list[i] > name_list[j])
                                std::swap(name_list[i], name_list[j]);
                        }
                    }
                }

                // Format short name text
                string_type s_names;
                for (size_type i = 0; i < name_list.size(); i++) {
                    s_names += name_list[i];
                    if ((i + 1) < name_list.size())
                        s_names += _Text(",");
                }
                option.names = s_names;

                // Format display name text
                string_type display_text;
                for (size_type i = 0; i < name_list.size(); i++) {
                    const string_type & name = name_list[i];
                    if (name.size() == 1)
                        display_text += _Text("-");
                    else if (name.size() > 1)
                        display_text += _Text("--");
                    else
                        continue;
                    display_text += name;
                    if ((i + 1) < name_list.size())
                        display_text += _Text(", ");
                }
                if (text_list.size() > 0) {
                    display_text += _Text(" ");
                }
                for (size_type i = 0; i < text_list.size(); i++) {
                    display_text += text_list[i];
                    if ((i + 1) < text_list.size())
                        display_text += _Text(" ");
                }
                option.display_text = display_text;

                size_type option_id = this->option_list.size();
                this->option_list.push_back(option);

                for (auto iter = name_list.begin(); iter != name_list.end(); ++iter) {
                    const string_type & name = *iter;
                    // Only the first option with the same name is valid.
                    if (this->option_map.count(name) == 0) {
                        this->option_map.insert(std::make_pair(name, option_id));
                    } else {
                        // Warning
                        printf("Warning: desc: \"%s\", option_id: %u, arg_name = \"%s\" already exists.\n\n",
                               this->title.c_str(), (uint32_t)option_id, name.c_str());
                    }
                }
            }
            return (err_code == Error::NoError) ? (int)nums_name : err_code;
        }

        void print_compact_style(VirtualTextArea<char_type> & text_buf) const {
            const PrintStyle<char_type> & ps = text_buf.print_style();
            std::vector<string_type> line_list;
            if (!is_empty_or_null(this->title)) {
                string_type title_text;
                text_buf.prepare_display_text(this->title,
                                              title_text,
                                              line_list,
                                              ps.max_column);
                text_buf.append_new_line();
                text_buf.append_text(0, line_list);
                text_buf.append_new_line();
            }

            for (auto const & option : this->option_list) {
                if (option.type == OptType::Text) {
                    if (!is_empty_or_null(option.desc)) {
                        string_type desc_text;
                        text_buf.prepare_display_text(option.desc,
                                                      desc_text,
                                                      line_list,
                                                      ps.max_column);
                        text_buf.append_text(0, line_list);
                    }
                } else {
                    if (!is_empty_or_null(option.display_text)) {
                        string_type display_text;
                        size_type column = text_buf.prepare_display_text(
                                                        option.display_text,
                                                        display_text, line_list,
                                                        ps.max_column - ps.ident_spaces,
                                                        true, false);
                        size_type lines = ((line_list.size() > 0) ? (line_list.size() - 1) : 0);
                        text_buf.append_text(ps.ident_spaces, line_list, false);
                        if (!is_empty_or_null(option.desc)) {
                            string_type desc_text;
                            text_buf.prepare_display_text(option.desc,
                                                          desc_text,
                                                          line_list,
                                                          ps.max_column - ps.max_start_pos);
                            if ((column + ps.ident_spaces) > (ps.max_start_pos - ps.min_padding)) {
                                lines++;
                            }
                            size_type total_lines = lines + line_list.size();
                            text_buf.append_text(ps.max_start_pos, lines, total_lines, line_list);
                        }
                    } else {
                        if (!is_empty_or_null(option.desc)) {
                            string_type desc_text;
                            text_buf.prepare_display_text(option.desc,
                                                          desc_text,
                                                          line_list,
                                                          ps.max_column);
                            text_buf.append_text(ps.ident_spaces, line_list);
                        }
                    }
                }
            }

            string_type out_text = text_buf.output_real();
            std::cout << out_text;
        }

        void print_relaxed_style() const {
            if (!is_empty_or_null(this->title)) {
                printf("%s:\n\n", this->title.c_str());
            }

            for (auto iter = this->option_list.begin(); iter != this->option_list.end(); ++iter) {
                const Option & option = *iter;
                if (option.type == OptType::Text) {
                    if (!is_empty_or_null(option.desc)) {
                        printf("%s\n\n", option.desc.c_str());
                    }
                } else {
                    if (!is_empty_or_null(option.display_text)) {
                        printf("  %s :\n\n", option.display_text.c_str());
                        if (!is_empty_or_null(option.desc)) {
                            printf("    %s\n\n", option.desc.c_str());
                        }
                    } else {
                        if (!is_empty_or_null(option.desc)) {
                            printf("%s\n\n", option.desc.c_str());
                        }
                    }
                }
            }
        }

    public:
        void find_all_name(size_type target_id, std::vector<string_type> & name_list) const {
            name_list.clear();
            for (auto iter = this->option_map.begin(); iter != this->option_map.end(); ++iter) {
                const string_type & arg_name = iter->first;
                size_type option_id = iter->second;
                if (option_id == target_id) {
                    name_list.push_back(arg_name);
                }
            }
        }

        void addText(const char * format, ...) __attribute__((format(printf, 2, 3))) {
            static const size_type kMaxTextSize = 4096;
            char text[kMaxTextSize];
            va_list args;
            va_start(args, format);
            int text_size = vsnprintf(text, kMaxTextSize, format, args);
            assert(text_size < (int)kMaxTextSize);
            va_end(args);

            Option option(OptType::Text);
            option.desc = text;
            this->option_list.push_back(option);
        }

#if defined(_MSC_VER)
        void addText(const wchar_t * format, ...) __attribute__((format(printf, 2, 3))) {
            static const size_type kMaxTextSize = 4096;
            wchar_t text[kMaxTextSize];
            va_list args;
            va_start(args, format);
            int text_size = _vsnwprintf(text, kMaxTextSize, format, args);
            assert(text_size < (int)kMaxTextSize);
            va_end(args);

            Option option(OptType::Text);
            option.desc = text;
            this->option_list.push_back(option);
        }
#endif

        int addOption(const string_type & names, const string_type & desc, const variant_t & value) {
            return this->addOptionImpl(OptType::String, names, desc, value, true);
        }

        int addOption(const string_type & names, const string_type & desc) {
            Variant default_value(size_type(0));
            return this->addOptionImpl(OptType::Void, names, desc, default_value, false);
        }

        void print(VirtualTextArea<char_type> & text_buf) const {
            if (text_buf.print_style().compact_style) {
                this->print_compact_style(text_buf);
            } else {
                this->print_relaxed_style();
            }
        }
    }; // class OptionsDescription

protected:
    std::vector<OptionDesc>                         option_desc_list_;
    std::vector<Option>                             option_list_;
    std::unordered_map<string_type, size_type>    option_map_;

    std::vector<string_type> arg_list_;

    string_type app_name_;
    string_type display_name_;
    string_type version_;

    PrintStyle<char_type> print_style_;

    Variable    empty_variable_;

public:
    BasicCmdLine() : print_style_() {
        this->version_ = _Text("1.0.0");
    }

protected:
    Option & getOptionById(size_type option_id) {
        assert(option_id >= 0 && option_id < this->option_list_.size());
        return this->option_list_[option_id];
    }

    const Option & getOptionById(size_type option_id) const {
        assert(option_id >= 0 && option_id < this->option_list_.size());
        return this->option_list_[option_id];
    }

    bool hasOption(const string_type & name) const {
        auto iter = this->option_map_.find(name);
        return (iter != this->option_map_.end());
    }

    size_type getOption(const string_type & name, Option *& option) {
        auto iter = this->option_map_.find(name);
        if (iter != this->option_map_.end()) {
            size_type option_id = iter->second;
            if (option_id < this->option_list_.size()) {
                option = (Option *)&this->getOptionById(option_id);
                return option_id;
            }
        }
        return Option::NotFound;
    }

    size_type getOption(const string_type & name, const Option *& option) const {
        auto iter = this->option_map_.find(name);
        if (iter != this->option_map_.end()) {
            size_type option_id = iter->second;
            if (option_id < this->option_list_.size()) {
                option = (const Option *)&this->getOptionById(option_id);
                return option_id;
            }
        }
        return Option::NotFound;
    }

public:
    static bool isWideString() {
        return (sizeof(char_type) != 1);
    }

    static string_type getAppName(char_type * argv[]) {
        string_type strModuleName = argv[0];
        size_type lastSepPos = strModuleName.find_last_of(kPathSeparator);
        if (lastSepPos != string_type::npos) {
            string_type appName;
            for (size_type i = lastSepPos + 1; i < strModuleName.size(); i++) {
                appName.push_back(strModuleName[i]);
            }
            return appName;
        } else {
            return strModuleName;
        }
    }

    size_type argn() const {
        return this->arg_list_.size();
    }

    std::vector<string_type> & argv() {
        return this->arg_list_;
    }

    const std::vector<string_type> & argv() const {
        return this->arg_list_;
    }

    string_type & getAppName() {
        return this->app_name_;
    }

    const string_type & getAppName() const {
        return this->app_name_;
    }

    string_type & getDisplayName() {
        return this->display_name_;
    }

    const string_type & getDisplayName() const {
        return this->display_name_;
    }

    string_type & getVersion() {
        return this->version_;
    }

    const string_type & getVersion() const {
        return this->version_;
    }

    void setDisplayName(const string_type & display_name) {
        this->display_name_ = display_name;
    }

    void setVersion(const string_type & version) {
        this->version_ = version;
    }

    bool isCompactStyle() const {
        return this->print_style_.compact_style;
    }

    bool isAutoFit() const {
        return this->print_style_.auto_fit;
    }

    size_type getMinPadding() const {
        return this->print_style_.min_padding;
    }

    size_type getMaxStartPos() const {
        return this->print_style_.max_start_pos;
    }

    size_type getMaxColumn() const {
        return this->print_style_.max_column;
    }

    string_type & getSeparator() {
        return this->print_style_.separator;
    }

    const string_type & getSeparator() const {
        return this->print_style_.separator;
    }

    void setCompactStyle(bool compact_style) {
        this->print_style_.compact_style = compact_style;
    }

    void setAutoFit(bool auto_fit) {
        this->print_style_.auto_fit = auto_fit;
    }

    void setMinPadding(size_type min_padding) {
        this->print_style_.min_padding = min_padding;
    }

    void setMaxStartPos(size_type start_pos) {
        this->print_style_.max_start_pos = start_pos;
    }

    void setMaxColumn(size_type max_column) {
        this->print_style_.max_column = max_column;
    }

    void setSeparator(const string_type & separator) {
        this->print_style_.separator = separator;
    }

    size_type order(const string_type & name) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return (size_type)option->variable.state.order;
        } else {
            return Option::NotFound;
        }
    }

    bool isRequired(const string_type & name) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return (option->variable.state.required != 0);
        } else {
            return false;
        }
    }

    bool required(const string_type & name) const {
        return this->isRequired(name);
    }

    bool isVisited(const string_type & name) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return (option->variable.state.visited != 0);
        } else {
            return false;
        }
    }

    bool visited(const string_type & name) const {
        return this->isVisited(name);
    }

    bool isAssigned(const string_type & name) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return (option->variable.state.assigned != 0);
        } else {
            return false;
        }
    }

    bool assigned(const string_type & name) const {
        return this->isAssigned(name);
    }

    bool getVariableState(const string_type & name, VariableState & variable_state) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            variable_state = option->variable.state;
            return true;
        } else {
            return false;
        }
    }

    Variable & getVariable(const string_type & name) {
        Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return option->variable;
        } else {
            return this->empty_variable_;
        }
    }

    const Variable & getVariable(const string_type & name) const {
        Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            return option->variable;
        } else {
            return this->empty_variable_;
        }
    }

    bool hasVar(const string_type & name) const {
        return this->hasOption(name);
    }

    bool getVar(const string_type & name, Variable & variable) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            variable = option->variable;
            return true;
        } else {
            return false;
        }
    }

    bool getVar(const string_type & name, variant_t & value) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            value = option->variable.value;
            return true;
        } else {
            return false;
        }
    }

    template <typename T>
    bool getVar(const string_type & name, T & value) const {
        const Option * option = nullptr;
        size_type option_id = this->getOption(name, option);
        if (option_id != Option::NotFound) {
            assert(option != nullptr);
            value = option->variable.value.template get<T>();
            return true;
        } else {
            return false;
        }
    }

    void setVar(const string_type & name, const Variant & value) {
        auto iter = this->option_map_.find(name);
        if (iter != this->option_map_.end()) {
            size_type option_id = iter->second;
            if (option_id < this->option_list_.size()) {
                Option & option = this->getOptionById(option_id);
                option.variable.value = value;
            }
        }
    }

    template <typename T>
    void setVar(const string_type & name, const T & value) {
        this->setVar(name, value);
    }

    size_type addDesc(const OptionDesc & desc) {
        size_type desc_id = this->option_desc_list_.size();
        this->option_desc_list_.push_back(desc);
        size_type index = 0;
        for (auto iter = desc.option_list.begin(); iter != desc.option_list.end(); ++iter) {
            const Option & option = *iter;
            size_type old_option_id = index;
            std::vector<string_type> arg_names;
            desc.find_all_name(old_option_id, arg_names);
            if (arg_names.size() != 0) {
                size_type new_option_id = this->option_list_.size();
                this->option_list_.push_back(option);
                // Actual desc id
                this->option_list_[new_option_id].desc_id = (std::uint32_t)desc_id;
                for (size_type i = 0; i < arg_names.size(); i++) {
                    if (this->option_map_.count(arg_names[i]) == 0) {
                        this->option_map_.insert(std::make_pair(arg_names[i], new_option_id));
                    } else {
                        printf("Warning: desc_id: %u, desc: \"%s\", option_id: %u, arg_name = \"%s\" already exists.\n\n",
                               (uint32_t)desc_id, desc.title.c_str(), (uint32_t)new_option_id, arg_names[i].c_str());
                    }
                };
            }
            index++;
        }
        return desc_id;
    }

    void printVersion() const {
        printf("\n");
        if (!is_empty_or_null(this->display_name_)) {
            printf("%s v%s\n", this->display_name_.c_str(), this->version_.c_str());
        } else {
            if (!is_empty_or_null(this->app_name_)) {
                printf("%s v%s\n", this->app_name_.c_str(), this->version_.c_str());
            } else {
                printf("No-name program v%s\n", this->version_.c_str());
            }
        }
        printf("\n");
    }

    void printUsage() const {
        static const size_type kMaxOutputSize = 4096;
        VirtualTextArea<char_type> text_buf(this->print_style_);
        // Pre allocate 16 lines text
        text_buf.reserve_lines(16);
        for (auto iter = this->option_desc_list_.begin();
             iter != this->option_desc_list_.end(); ++iter) {
            const OptionDesc & desc = *iter;
            desc.print(text_buf);
            text_buf.reset();
        }

        if (this->print_style_.compact_style) {
            std::cout << std::endl;
        }
    }

    int parseArgs(int argc, char_type * argv[], bool strict = false) {
        int err_code = Error::NoError;

        this->arg_list_.clear();
        this->arg_list_.push_back(argv[0]);

        this->app_name_ == this_type::getAppName(argv);

        int i = 1;
        bool need_delay_assign = false;
        string_type last_arg;

        while (i < argc) {
            bool has_equal_sign = false;
            bool is_delay_assign = false;
            size_type start_pos, end_pos;

            string_type arg = argv[i];
            this->arg_list_.push_back(argv[i]);

            size_type separator_pos = arg.find(char_type('='));
            if (separator_pos != string_type::npos) {
                if (separator_pos == 0) {
                    // Skip error format
                    err_code = Error::CmdLine_IllegalFormat;
                    i++;
                    continue;
                }
                assert(separator_pos > 0);
                end_pos = separator_pos;
                has_equal_sign = true;
            } else {
                end_pos = arg.size();
            }

            string_type arg_name, arg_value;
            const char_type * value_start = nullptr;
            int arg_name_type = 0;
            start_pos = 0;
            char head_char = arg[0];
            assert(head_char != char_type(' '));
            if (head_char == char_type('-')) {
                if (arg[1] == char_type('-')) {
                    // --name=abc
                    start_pos = 2;
                } else {
                    // -n=abc
                    start_pos = 1;
                }

                // Parse the arg name or value
                string_copy(arg_name, arg, start_pos, end_pos);
                if (arg_name.size() > 0) {
                    if (start_pos == 1) {
                        // -n=abc
                        if (arg_name.size() == 1) {
                            arg_name_type = 1;
                            // short prefix arg name format can be not contains "="
                            if (has_equal_sign) {
                                need_delay_assign = false;
                                last_arg = "";
                            } else {
                                need_delay_assign = true;
                                last_arg = arg_name;
                            }
                        } else {
                            if (strict) {
                                err_code = Error::CmdLine_ShortPrefixArgumentNameTooLong;
                            }
                        }
                    } else if (start_pos == 2) {
                        // --name=abc
                        if (arg_name.size() > 1) {
                            // long prefix arg name format
                            arg_name_type = 2;
                            need_delay_assign = false;
                            last_arg = "";
                        } else {
                            if (strict) {
                                err_code = Error::CmdLine_LongPrefixArgumentNameTooShort;
                            }
                        }
                    }

                    if ((arg_name_type > 0) && has_equal_sign) {
                        // Parse the arg value
                        value_start = &argv[i][0] + end_pos + 1;
                        string_copy(arg_value, arg, end_pos + 1, arg.size());
                    }
                } else {
                    if (strict) {
                        err_code = Error::CmdLine_EmptyArgumentName;
                    }
                }
            } else {
                // Maybe is a argument value.
            }

            if (arg_name_type == 0) {
                // The arg value equal full arg[i]
                value_start = &argv[i][0];
                arg_value = arg;
                if (need_delay_assign) {
                    assert(last_arg.size() == 1);
                    arg_name = last_arg;
                    arg_name_type = 1;
                    is_delay_assign = true;
                } else {
                    // Unrecognized argument
                    arg_name_type = -1;
                    if (strict) {
                        err_code = Error::CmdLine_UnrecognizedArgument;
                    }
                }

                need_delay_assign = false;
                last_arg = "";
            }

            if ((arg_name_type > 0) && (arg_name.size() > 0)) {
                bool exists = this->hasVar(arg_name);
                if (exists) {
                    Variable & variable = this->getVariable(arg_name);
                    variable.state.order = i;
                    variable.state.visited = 1;
                    variable.name = arg_name;
                    if (!has_equal_sign && !is_delay_assign) {
                        // If arg name no contains "=" and it's not delay assign.
                        if (variable.state.is_default == 0) {
                            need_delay_assign = false;
                            last_arg = "";
                        }
                    } else {
#if 1
                        bool convertible = false;
                        try {
                            StringConverter<variant_t, char_type> stringConverter(arg_value, value_start);
                            variable.value = ::jstd::apply_visitor(stringConverter, variable.value);
                            convertible = true;
                        } catch(const std::invalid_argument & ex) {
                            std::cout << "std::invalid_argument::what(): " << ex.what() << '\n';
                        } catch(const std::out_of_range & ex) {
                            std::cout << "std::out_of_range::what(): " << ex.what() << '\n';
                        } catch (const jstd::BadVariantAccess & ex) {
                            std::cout << "jstd::BadVariantAccess::what(): " << ex.what() << '\n';
                        }
                        if (convertible)
                            variable.state.assigned = 1;
                        else
                            err_code = Error::CmdLine_CouldNotParseArgumentValue;
#else
                        bool convertible = Converter<char_type>::try_convert(variable.value, arg_value, value_start);
                        if (convertible)
                            variable.state.assigned = 1;
                        else
                            err_code = Error::CmdLine_CouldNotParseArgumentValue;
#endif
                    }
                } else {
                    need_delay_assign = false;
                    last_arg = "";
                    if (strict) {
                        // Unknown argument: It's a argument, but can't be found in variable map.
                        err_code = Error::CmdLine_UnknownArgument;
                    }
                }
            }

            if (err_code != Error::NoError)
                break;

            // Scan next argument
            i++;
        }
        return err_code;
    }
};

typedef BasicConfig<char>       Config;
typedef BasicCmdLine<char>      CmdLine;

typedef BasicConfig<wchar_t>    ConfigW;
typedef BasicCmdLine<wchar_t>   CmdLineW;

} // namespace app

#endif // APP_CMD_LINE_H
